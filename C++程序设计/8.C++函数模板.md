# 1 基本语法

```cpp
// 声明你是模板函数（示例）
// 这个声明仅对第一个函数生效
template <class T>  // 或者 template <typename T>
void mySwap(T&a, T&b) {
  T temp = a;
  a = b;
  b = temp;
}
```

两种使用方式：

1. **自动类型推导**：

   ```cpp
   // 1. 自动类型推导
   cout << "a: " << a << " b: " << b << endl;
   mySwap(a, b);
   cout << "a: " << a << " b: " << b << endl;
   
   double da = 1.2;
   double db = .343;
   
   cout << "da: " << da << " db: " << db << endl;
   mySwap(da, db);
   cout << "da: " << da << " db: " << db << endl;
   ```

2. **显示指定类型**：

   ```cpp
     // 2. 显示指定类型
     mySwap<int>(a, b);
   ```

# 2 调用规则

__函数模板和普通函数在一起调用规则__：

- 函数模板可以像普通函数那样被重载；

  ```c++
  template <typename T>
  void print(T a) {
    cout << a << endl;
  }
  
  template <typename T>
  void print(T a, T b) {
    cout << a << endl;
    cout << b << endl;
  }
  ```

- C++ 编译器优先考虑**普通函数**（模板函数与普通函数同名）；

- 如果函数模板可以产生一个__更好的匹配__，那么选择模板；

- 可以通过**空模板实参列表**的语法限定编译器只能通过模板匹配；

  如果**一定**要使用模板函数，就使用下列语法：`myadd<>(a, b)`。

**区别**：

- 函数模板不允许自动类型转化；
- 普通函数能够自动进行类型转化；

```cpp
#include <iostream>

using namespace std;

// 模板函数不行
template <class T>
int myAdd(T a, T b) {
  return a + b;
}

// 普通函数可以进行自动类型转换
int myAdd(int a, char c) { return a + c; }

void test02() {
  int a = 10;
  int b = 20;
  char c1 = 'a';
  char c2 = 'b';

  // 优先执行下面的那个函数
  // 因为优先使用普通的
  myAdd(a, c1);
  // 执行上面的那个函数
  myAdd(a, b);

  // 调用下面的
  // 因为模板不会对类型进行自动类型转换
  myAdd(c1, b);
}

int main() {
  test02();
  return 0;
}
```

> 可以通过调试来查看函数的调用！

# 3 实现机制

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2024-04-19%2F69d325c969281695fc2b9fafa71b0606--1a9d--image-20240419220138113.png" alt="image-20240419220138113" style="zoom: 67%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2024-04-19%2F30b8ed5d5afd051cb5ff97227f046eba--f61e--image-20240419222302862.png" alt="image-20240419222302862" style="zoom:80%;" />

```cpp
#include <iostream>

using namespace std;

template <typename T>
T myAdd(T a, T b) {
  return a + b;
}

int main() {
  int a = 10;
  int b = 20;
  double da = 1.14;
  double db = 2.14;
  myAdd(a, b);
  myAdd(da, db);
  return 0;
}
```

它会生成两个函数，在生成的汇编文件中有（示例）：

```assembly
call _Z5myAddIiET_S0_S0_ 
...
call _Z5myAddIdET_S0_S0_
```

可以看到调用了两个不同函数。

添加 `myAdd(a, a);` 后，有：

```assembly
call _Z5myAddIiET_S0_S0_ 
...
call _Z5myAddIdET_S0_S0_
...
call _Z5myAddIdET_S0_S0_
```

可以看到第一个和第三个调用的函数一致，生成了两个函数。

---

**函数模板机制结论**：

编译器并不是把函数模板处理任何类型的函数；

函数模板通过具体类型产生不同的函数；

编译器会对函数模板进行**两次编译**，在*声明*的地方对模板代码本身进行编译，在*调用*的地方对参数替换后的代码进行编译。

