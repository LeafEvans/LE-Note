# 1.最大公约数

**【题目内容】**

给定两个数，求这两个数的最大公约数。

例如：

输入：20 40

输出：20

```c
#include <stdio.h>

int main(void)
{
	int a, b, c; // 定义了三个整形变量
    
	scanf("%d %d", &a, &b); // 输入
	while (c = a % b)
	{
		a = b;
		b = c;
	}
	/*
	将a/b的余数赋值给c，
	并且利用C语言的真假特性（即零为假，非零为真），
	制定循环
	*/
	printf("%d", b); // 输出除数b
    
	return 0;
}
```
**【解析】**

根据辗转相除法，取两个数，一个充当被除数，一个充当除数，求两者最大公约数。当被除数除以除数的余数为零时，除数即为最大公约数。当被除数除以除数的余数不为零，此时将被除数替换为原来的除数，除数替换为原来的余数；然后重复上述的步骤，当余数为零时，此时除数就为最大公约数。

**【扩展】**

```c
// 最大公约数
#include <stdio.h>

int main(void)
{
    int a = 0, b = 0, c = 0;

    scanf("%d %d", &a, &b);

    int ai = a, bi = b;

    while (c = a % b)
    {
        a = b;
        b = c;
    }
    printf("%d\n", (ai * bi) / b); // ；两个数相乘除以最小公倍数就是最大公倍数，把公因子化为唯一一个
// 那个公约数可以和一个因子结合成为一个数，另一个因子结合为另一个数
    return 0;
}
```

递归：

```c
long long gcd(long long a, long long b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}
```

# 2.**出生日期输入输出**

## 描述
输入一个人的出生日期（包括年月日），将该生日中的年、月、日分别输出。

数据范围：年份满足 1990≤_y_≤2015 ，

月份满足 1≤_m_≤12  ，

日满足  1≤_d_≤30  。

### 输入描述：
输入只有一行，出生日期，包括年月日，年月日之间的数字没有分隔符。
### 输出描述：
三行，第一行为出生年份，第二行为出生月份，第三行为出生日期。输出时如果月份或天数为1位数，需要在1位数前面补0。
## 示例

输入：20130225 

输出：year=2013 

​           month=02 

​           date=25

## 解析
```c
#include <stdio.h>

int main(void)
{
	int year, month, day;
    
	scanf("%4d%2d%2d", &year, &month, &day); 
	printf("year=%d\nmonth=%02d\nday=%02d\n",year,month,day);
    
	return 0;
}
```
**%4d%2d%2d**表示输入一个8位数，分成4位数、2位数、2位数放在三个不同的变量中。

在**scanf**函数中，**%md**（m表示一个常数）会读取m位数。而**printf**函数也有相似的效果，即输出m位数。

而前面加上**%0**则会将空缺的位（即空格）用0来填充。

（类似的还有**%.2f**之类的来表示小数点后两位，**%-2d**代表左对齐两格，**%2d**代表右对齐两格。

还有**%*2d**代表不读取这两位数，如`scanf("%2d%*2d%2d", &a, &b);`

代表输入一个6位数，前面两位赋给a，后面两位赋给b，中间两位不读取。）

# 3.**学生基本信息输入输出**
## 描述
依次输入一个学生的学号，以及3科(C语言，数学，英语)成绩，在屏幕上输出该学生的学号，3科成绩（注：输出成绩时需进行四舍五入且保留2位小数）。

数据范围：学号满足 1≤_n_≤20000000  ，各科成绩使用百分制，且不可能出现负数。

### 输入描述：
学号以及3科成绩，学号和成绩之间用英文分号隔开，成绩之间用英文逗号隔开。
### 输出描述：
学号，3科成绩，输出格式详见输出样例。

## 示例

输入：17140216;80.845,90.55,100.00

输出：The each subject score of No. 17140216 is 80.85, 90.55, 100.00.

## 解析
```c
#include <stdio.h>

int main(void)
{
	int id = 0;
    
	float c = 0.0f, math = 0.0f, eng = 0.0f;
	scanf("%d;%f,%f,%f",&id,&c,&math,&eng);
	printf("The each subject score of No. %d is %.2f, %.2f, %.2f", id, c, math, eng);
    
	return 0;
}
```
定义浮点型时在0.0后加上f是因为浮点数默认是**double**类型的，而不是**float**类型的。
# 4.**小乐乐找最大数**
## 描述
小乐乐获得4个最大数，请帮他编程找到最大的数。
### 输入描述：
一行，4个整数，用空格分开。
### 输出描述：
一行，一个整数，为输入的4个整数中最大的整数。
## 示例

输入：5 8 2 5

输出：8

## 解析
```c
#include <stdio.h>

int main(void)
{
	int arr[4] = { 0 };		/*定义了一个大小为四的数组*/
	int i = 0;				/*定义了一个变量i*/
    int max = 0;
    
	while (i < 4)			/*使用循环遍历数组，对每个元素进行输入*/
	{
		scanf("%d", &arr[i]);
		i++;
	}
	i = 0;					/*重新将i定义为零*/
    
	max = arr[0];		/*先假定最大数为数组第一个元素*/
    
	while (i < 4)			/*使用循环将max与数组内每一个元素作比较，定义新的max*/
	{
		if (arr[i] > max)
			max = arr[i];
		i++;
	}
	printf("%d", max); // 输出max
    
	return 0;
}
```
打擂台！
```c
#include <stdio.h>

int main(void)
{
	int max = 0;		// 定义三个变量
	int i = 1;			// i = 1，使得等会还有三次输入
	int n = 0;

	scanf("%d", &max);	// 假定最大值
	while (i < 4)		// 利用循环，比较新输入的值与max的大小
	{
		scanf("%d", &n);
		if (n > max)
			max = n;	// 若新输入的更大，则将max替换为n
		i++;
	}
	printf("%d", max);

	return 0;
}
```
# 5.求n的阶乘
```c
#include <stdio.h>

int main(void)
{
    int n = 0, i = 0, ret = 1; // 定义三个变量
    
    scanf("%d", &n);           // 输入n的值  
    for (i = 1; i <= n; i++)   // 每次循环都会增大i的值  
    {
        ret *= i;              // ret每次乘增大的i的值，直到i等于n
    }
    printf("%d", ret);         // 输出
    
    return 0;
}
```
（考察循环语句的知识。）
# 6.求1!+2!+...+10!的值
## （1）方法一
```c
#include <stdio.h>

int main(void)
{
    int n = 0, i = 0, ret = 1, sum = 0;  // 定义了四个变量
    
    for (n = 1; n <= 10; n++)            // n的循环
    {
        for (i = 1, ret = 1; i <= n; i++)
        /*i的循环，并且在每次的外层循环结束后，初始化ret*/
        {                                   
            ret *= i;                     // 与求n的阶乘方法类似
        }
        sum += ret;                       // 求sum的值 
    }
    printf("%d", sum);                    // 打印
    
    return 0;
}
```
## （2）方法二

```c
#include <stdio.h>

int main(void)
{
    int i = 0, j = 1, n = 0;    // 定义三个整形
    
    for (i = 1; i <= 10; i++)   // for循环
    {
        j *= i;                 /*每次循环，每个阶乘都乘一个比最大数大一的数*/
        n += j;                 /*形成新的阶乘，而后求和*/
    }
    printf("%d", n);            // 输出
    
    return 0;
}
```
# 7.二分法查找指定元素（有序数组）
## 普通版：
```c
#include <stdio.h>

int main(void)
{
    // 定义有序整型数组
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 从标准输入读取要查找的元素
    int n = 0;
    scanf("%d", &n);

    // 计算数组大小并初始化左右边界及中间位置
    int sz = sizeof(arr) / sizeof(arr[0]);
    int leaf = 0;
    int right = sz - 1;
    int mid = (leaf + right) / 2;

    // 循环执行二分查找
    while (leaf <= right)
    {
        mid = (leaf + right) / 2;
        if (arr[mid] < n)
        { // 如果中间元素小于指定元素，则调整左边界即找右侧
            leaf = mid + 1;
        }
        else if (arr[mid] > n)
        { // 如果中间元素大于指定元素，则调整右边界即找左侧
            right = mid - 1;
        }
        else
        { // 如果中间元素恰好等于指定元素，则退出循环
            break;
        }
    }

    // 根据查找结果输出提示信息
    if (arr[mid] == n)
    {
        printf("找到了，下标是 %d\n", mid);
    }
    else if (leaf > right)
    {
        printf("找不到\n");
    }

    return 0;
}

```
若**i**大于指定数组的大小，如**n = 17**，则**n**始终大于**right**，则会一直执行`else if`语句，最终使得左边界大于右边界，跳出循环。

而后执行外部的`else if`语句。

`mid = (leaf + right) / 2`语句可用`mid = leaf + (right - leaf) / 2`语句来替代，

防止**leaf + right**的数据超出整形所能表示的范围导致数据溢出，从而造成数据的缺失。

## 函数版：
```c
#include <stdio.h>

int binary_search(int arr[10], int x, int y)
{
    int leaf = 0;
    int right = y - 1;
    
    while (leaf <= right)
    {
        int mid = leaf + (right - leaf) / 2;
        if (x < arr[mid])
        {
            right = mid - 1;
        }
        else if (x > arr[mid])
        {
            leaf = mid + 1;
        }
        else
        {
            return mid;
        }
    }
    return -1;
}

int main(void)
{
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int k = 0;
    int n = 0;
    int sz = sizeof(arr) / sizeof(arr[0]);
    
    scanf("%d", &k);
    if ((n = binary_search(arr, k, sz)) == -1)
    {
        printf("没找到,超出寻找范围\n");
    }
    else
    {
        printf("找到了，下标是%d\n", n);
    }
    
    return 0;
}
```

在 C 语言中，数组作为函数参数时会退化为指针类型，此时无法在函数内部直接求得数组的元素个数。

这是因为数组传递给函数时，只传递了数组的首地址，并没有传递数组的长度信息。

所以，当你在函数内部使用 `**sizeof(arr) / sizeof(arr[0])**` 的方式计算数组的长度时，

实际上是计算了指针的大小除以数组元素的大小，结果始终为 $1$ 或者任意固定的值，无法得到正确的数组长度。

为了解决这个问题，你需要通过额外的参数将数组的长度传递给函数。

例如，在你修复的代码中，你添加了一个参数$y$来表示数组的长度，并将其作为二分查找的边界条件。

这样，你就能在函数内部正确地使用这个长度信息。

# 8.字符串由两端向中间显现
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char arr1[] = "Welcome to SCU!!!!";//定义两个字符数组
    char arr2[] = "##################";
    int i = 0, j = strlen(arr2) - 1;//定义左右边界

    while (i < j + 2)//替换完中间两个数字后，又进行了i++，j--，导致不满足循环条件，跳出循环，无打印
    {                //因此通过改变循环条件是，使i<j+2时跳出循环，就是在进行完i++，j--的计算后，i=9，j=8  
        printf("%s\n", arr2);//满足条件，继续循环
        arr2[i] = arr1[i], arr2[j] = arr1[j];
        i++, j--;
    }

    return 0;
}
```
输出效果：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2F8346c01809eb55c05f3b35bddff40959--12a1--1695902336949-6b667cd3-7eb8-4d9b-87d3-fbfa09bb1c70.png" alt="image.png" style="zoom:80%;" />

# 9.模拟用户登录情景
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    int i = 0;
    char passwd[20];
    
    for (i = 1; i < 4; i++)
    {
        printf("请输入密码:>");
        scanf("%s", passwd);
        if (strcmp(passwd, "abc123") == 0)
        {
            printf("登录成功\n");
            break;
        }
        else if (i < 3)
        {
            printf("密码错误，您还有%d次机会", 3 - i);
        }
        else
        {
            printf("您的账号已锁定");
        }
    }
    
    return 0;
}
```
# 10.字母大小写转换

通过`while`循环可以进行多组数据的输入，当读取不成功的时候，就会跳出循环。

```c
#include <stdio.h>

int main(void)
{
    char ch = 0;

    getchar();
    while (scanf("%d", &ch) == 1) // 当scanf读取成功时，它会返回成功读到数据的个数；否则返回EOF，跳出循环
    {														  // 再一次循环时，可以读取换行符，下面两个条件判断语句不执行
        if (ch > 'a' && ch < 'z')
            printf("%c", ch - ('a' - 'A'));
        else if (ch > 'A' && ch < 'Z')
            printf("%c", ch + ('a' - 'A'));
    }

    return 0;
}
```

# 11.打印100~200之间的素数
## 版本一：
```c
#include <stdio.h>

int main(void)
{
    int i = 0;                   // 定义变量
    
    for (i = 100; i <= 200; i++) // 制定循环
    {
        int j = 0, flag = 1;     // 定义两个变量
        
        for (j = 2; j < i; j++)  // 判断i是否为素数
        {
            if (i % j == 0)      // 判断模是否为0
            {
                flag = 0;        // 如果模为0
                break;           // 改变flag的值
            }                    // 跳出这层循环
        }
        if (flag == 1)           // 如果flag为1
            printf("%d\n", i);   // 说明在循环过程中
    }                            // flag一直没有被改变
    
    return 0;                    // 即所有的2~i-1的数
}                                // 都无法整除i，打印
```
## 版本二：
```c
for (j = 2; j <= sqrt(i); j++)
```
将第二层循环条件改变。

因为如果一个数不是素数，它的两个因子中的其中一个，必定小于该数的平方根，只要判断有无小于平方根而大于1的那个因子即可。

如果有，就会整除；如果无，在该平方根之后也不可能找到另一个因子。

## 版本三：
```c
for (i = 101; i <= 200; i += 2)
```
将第一层循环条件改变。因为一个数如果是素数，必定不是偶数，所以循环条件改成奇数判断。
## 函数版：
```c
#include <stdio.h>
#include <math.h>

int is_prime(int n)
{
    int i = 0;
	
    for (i = 2; i <= sqrt(n); i++)
    {
        if (n % i == 0)
            return 0; // 当遇到整除的时候，就会返回0
    }
	
    return 1; // 当没有整除的时候，就会返回1
}

int main(void)
{
    int i = 0;
    int count = 0;
	
    for (i = 101; i <= 200; i += 2)
    {
        if (is_prime(i))
        {
            printf("%d\n", i);
            count++;
        }
    }
    printf("\ncount = %d\n", count);
	
    return 0;
}
```
# 12.调用一次函数，num的值加一
错误示范：
```c
#include <stdio.h>

void Add(int *x)
{
    *x++;
}

int main(void)
{
    int num = 0;
	
    Add(&num);
    Add(&num);
    printf("%d\n", num);
	
    return 0;
}
```
`*x++`这个语句因为没有括号，执行流程是这样的：

先对指针变量**x**进行解引用，再对指针变量**x**进行`++`操作。

因此：

```c
#include <stdio.h>

void Add(int *x)
{
    (*x)++;
}

int main(void)
{
    int num = 0;
	
    Add(&num);
    Add(&num);
    printf("%d\n", num);
	
    return 0;
}
```
`(*x)++`来正确的表示。

因此，在解引用操作中，最好把解引用的指针变量用小括号给圈起来。

# 13.从大到小输出
```c
#include <stdio.h>

int main(void)
{
    int a = 0;
    int b = 0;
    int c = 0;
    int temp = 0;

    scanf("%d %d %d", &a, &b, &c);
    if(b>a)
    {
        temp=a;
        a=b;
        b=temp;
    }
    if(c>a)
    {
        temp=a;
        a=c;
        c=temp;
    }
    if(c>b)
    {
        temp=c;
        c=b;
        b=temp;
    }
    printf("%d %d %d\n",a,b,c);

    return 0;
}
```
# 14.汉诺塔问题
大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2Fb1f836a3a153a4e7570a3b80e3716901--26f2--1697073569580-9a1a83f7-b2aa-44eb-b85e-bcfb4864ae08.gif" alt="99ba549ce59a40b1a7f30570b2483a21.gif" style="zoom:67%;" />

若有n个圆盘，由参考系，将A柱最底下的圆盘当成地面，先做A->B的n-1个汉诺塔问题。然后在将A柱最底下的圆盘由A->C,而后再做B->C的n-1汉诺塔问题。

由此，代码如下：

```c
#include <stdio.h>

void move(char A, char B, int n)
{
    printf("把第%d个圆盘从%c->%c\n", n, A, B);
    // 定义move函数，实现两柱圆盘移动
}

void HanoiTower(char A, char B, char C, int n)
{
    if (1 == n)
        move(A, C, n);
        // 若n=1，直接A->C
    else
    // n>1
    {
        HanoiTower(A, C, B, n - 1);
        // 先实现A->B的n-1个汉诺塔问题
        move(A, C, n);
        // 移动A柱底层圆盘
        HanoiTower(B, A, C, n - 1);
        // 再实现B->C的n-1个汉诺塔问题
    }
}
```


# 15.韩信点兵

## 描述
都听说过“韩信点兵，多多益善”这个成语，韩信才智过人，从不直接清点人数。只要让士兵 33 人一排，55 人一排，77 人一排的变换队形，查看队尾人数便能清点队伍总人数。
## 输入
第1行是一个整数 _n_，表示随后有 _n_ 组数据。每组数据占一行，包括三种队形的队尾人数_a_,_b_,_c_，用空格隔开。已知队伍总人数不小于 10，不大于100。
## 输出
对每组数据，输出相应的队伍总人数，并换行。不存在则输出`Impossible`，并换行。
## 示例
### 输入
```c
3
1 1 2
2 4 6
2 3 6
```
### 输出
```c
16
Impossible
83
```
## 解析
```c
int count_soliders(int num1, int num2, int num3) // 暴力穷举
{
    int i = 10;

    while (1)
    {
        if (i > 100)
            return 0;
        if ((i % 3 == num1) && (i % 5 == num2) && (i % 7 == num3)) // 满足条件就输出
            return i;
        i++;
    }
}
```
# 16.回文数
## 描述
程序中输入一个正整数，请判断他是否为回文数。

提示：回文数：类似1234321，123321等这样，顺序和逆序相同的整数称为回文数。

## 输入
一个正整数n。
## 输出
若n是回文数，输出Yes，否则输出No。
## 解析
```c
#include <stdio.h>

int is_palindrome(int num)
{
    int orignal_num = num; // 原本的数
    int reverse_num = 0;   // 倒着的数

    while (num)                                    // 限定条件，当num>0时，才会循环，因为它是整数除法，所以最后不会产生小数，而是零
    {                                              // 零为假，跳出循环
        reverse_num = reverse_num * 10 + num % 10; // 先加上取余得到个位
        num /= 10;                                 // 一次循环后，num除以10再赋给num，而反转数个位上的2乘上10，变成十位上的2
    }                                              // 之后再加上新的num取模得到的新的个位，如此循环，形成与原数顺序相反的数
    if (orignal_num == reverse_num)                // 判断顺序与倒序是否相等
        return 1;
    else
        return 0;
}
```
# 17.字符串逆序
## 方法一:
```c
#include <stdio.h>
#include <string.h>

void swap(char *a, char *b)
{
    char temp = *a;

    *a = *b;
    *b = temp;
}

void reverse_string(char *str)
{
    int leaf = 0;
    int right = strlen(str) - 1; // 注意右下标是字符串长度减一
                                 // strlen()可以在数组中使用，本质上也是将指针传给它，与运算符sizeof()不同
    while (leaf < right)
    {
        swap(&str[leaf], &str[right]);
        leaf++;
        right--;
    }
}
```
## 方法二:
```c
void reverse_string(char *str) // 传字符串第一个字符的地址
{
    char tem = *str;       // 将第一个字符赋给临时变量tem
    int len = strlen(str); // 计算字符串的长度

    *str = *(str + len - 1);     // 将最后一个字符赋给第一个字符
    *(str + len - 1) = '\0';     // 最后一个字符赋值为'\0'，形成新的字符末尾
    if (strlen(str + 1) > 1)     // 计算下一次递归的字符串长度，当2个字符及以上后，进行递归(因为2个字符及以上才要交换)
        reverse_string(str + 1); // 进行递归，每次递归都会创建一个新的临时变量存储字符串第一个字符
    *(str + len - 1) = tem;      // 将临时变量赋给字符串最后一个字符
}
```

![image.png](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2Fc15215cdd6d98e456205466dde11cf71--8f92--1697807039832-1a5994f6-2dbf-4b4b-a230-f9cc5083b3bf.png)
# 18.n的k阶乘
```c
double Pow(int n, int k) // 注意k的不同情况
{
    if (k > 0)
        return n * Pow(n, k - 1);
    else if (k < 0)
        return (1.0 / n) * Pow(n, k + 1);
    else
        return 1;
}
```

# 19.整除问题

## 描述

输入N个正整数，输出其中最小的能整除3的数。

## 输入

每行输入包含一组测试数据，包含N+1个整数，之间用空格分隔。 第1个整数代表N（1<=N<=100），后面N个整数是需要统计的数据。

## 输出

如果存在满足条件的数，那么输出该数，如果没有则输出Null。

## 样例

| 输入       | 输出 |
| ---------- | ---- |
| 4 42 7 6 2 | 6    |
| 4 1 4 7 13 | Null |

## 解析

```C
#include <stdio.h>

int main(void)
{
    int arr1[100] = {0}; // 用于存储输入数据的数组1
    int arr2[100] = {0}; // 用于存储数组1中能被整除的元素
    int n = 0;           // 组数n
    int i = 0;           // 两个用于循环的变量i和j
    int j = 0;
    int min = 0; // 最小值初始化为0

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        scanf("%d", &arr1[i]);
        if (arr1[i] % 3 == 0)
        {
            arr2[j] = arr1[i]; // 下标为j的数组2元素被赋值为能被3整除的数组1的元素
            j++;               // 存储的元素个数等于j
        }
    }
    min = arr2[0]; // 假设arr[0]是数组的最小值
    while (j > 0)  // 大于0而不是大于等于0，因为如果在大于0时，arr[j]仍大于arr[0]，说明arr[0]就是最小值，减少1次循环
    {
        if (arr2[j - 1] < min) // 在数组2中最大的数组元素下标为j-1，因此从它开始
            min = arr2[j - 1]; // 如果更小，则替换
        j--;
    }
    if (min) // 非0即为真，执行if语句；0即为假，执行else语句
        printf("%d\n", min);
    else
        printf("Null\n");

    return 0;
}
```

# 20.数字翻转

## 描述

现在有任意两个正整数，问它们两个数翻转的和是否等于两个数的和的翻转。比如12,34便满足该条件，即12+34=46,而64=21+43。  

## 输入

先输入一个正整数表示将要测试数据的组数 n。每行两个正整数a和b（0<a,b<=10000）。

## 输出

如果满足题目的要求输出YES，否则输出NO 。

## 输入示例

```
2

12 34

99 1
```

## 输出示例

```
YES

NO
```



## 解析

```C
#include <stdio.h>

int reverse_num(int origal_num) // 回文数求法
{
    int reverse_num = 0;

    while (origal_num)
    {
        reverse_num = reverse_num * 10 + origal_num % 10;
        origal_num /= 10;
    }

    return reverse_num;
}

int main(void)
{
    int n = 0;
    int i = 0;

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        int x = 0;
        int y = 0;

        scanf("%d %d", &x, &y);
        if (x + y == reverse_num(reverse_num(x) + reverse_num(y))) // 题目所述
            printf("YES\n");
        else
            printf("NO\n");
    }

    return 0;
}
```

# 21.打酱油

## 描述

小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 

## 输入

输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。

## 输出

输出一个整数，表示小明最多可以得到多少瓶酱油。

## 样例

| 输入 | 输出 |
| ---- | ---- |
| 40   | 5    |
| 80   | 11   |

## 解析

```C
#include <stdio.h>

int main(void)
{
    int n = 0; // 钱数
    int i = 0; // 循环次数
    int a = 0; // 瓶数

    scanf("%d", &n);
    n /= 10;             // 基本瓶数，没加附赠的
    a = n + (n / 5) * 2; // 先算5瓶的有几组，有几组就几组*2
    n %= 5;              // 将n赋值为它取模5的数，就是除了5个5个分组，还剩几瓶
    if (n / 3)           // 把剩的几瓶/3，就可以看到剩的几瓶至多可以分为几个3组了
        a += n / 3;
    printf("%d", a); // 打印出瓶数

    return 0;
}
```

# 22.中忍考试

## 描述

正巧今天是鸣人升为中忍的日子，他决定带着他的小伙伴们去一乐大吃一顿庆祝庆祝。

来到一乐门前时，鸣人惊呆了，门前已经排了好几列队伍了，而且每个队伍中的人还都不少。

鸣人已经饿的肚子咕咕叫了，他想知道排哪列队伍可以最快吃上饭。

我们规定排队的人有3种，并且每种食物的制作时间都不同。具体如下：

> A种人：中忍考试没过，一个人伤心的出来吃闷饭，这种人会点1碗拉面+1份烤肉+1杯饮料。
>
> B种人：有说有笑的情侣，两个人都通过了中忍考试，他们会点2碗拉面+1份烤肉。
>
> C种人：一家三口，两个中年人带一个孩子，围观中忍考试的观众，他们会点3碗拉面+3份烤肉+2杯饮料。
>

每种食物的制作时间在输入要求中给出。

## 输入

每组第一行输入4个正整数n，l，k，y，n表示队伍列数，l表示拉面的制作时间，k表示烤肉的制作时间，y表示饮料的制作时间。

所有正整数均在32位int范围内。

接下来n行，每行输入一个字符串，表示此列队伍排队情况，

字符串仅由A、B、C这三个字母组成，每个字母对应题目描述中的某种人，字符串长度不超过100。

## 输出

对于每组输入，输出可以让鸣人最快吃上饭的那个队伍的排队时间。

## 样例输入

```
3 3 4 1
ABCABC
AACC
ACBAA
```

## 样例输出

```
57
```

## 解析

```c
#include <stdio.h>

int main(void)
{
    int i = 0;
    int n = 0;
    int l = 0;
    int k = 0;
    int y = 0;
    int min = -1; // 先定义为0

    scanf("%d %d %d %d", &n, &l, &k, &y);
    for (i = 0; i < n; i++)
    {
        int time = 0;
        int j = 0;
        char team[100] = {'\0'};

        scanf("%s", team); // 输入字符串
        for (j = 0; team[j] != '\0'; j++)
        {
            if (team[j] == 'A') // 满足条件就输出按照题述作运算
                time += (l + k + y);
            else if (team[j] == 'B')
                time += (2 * l + k);
            else if (team[j] == 'C')
                time += (3 * l + 3 * k + 2 * y);
        }
        if (min > time || min == -1) // 如果min还为-1，则将time的值赋给min，因为time必大于0
            min = time;
    }
    printf("%d\n", min);

    return 0;
}
```

# 23.计算电梯时间

## 描述

某城市最高的建筑只有一部电梯。一份电梯升降任务表由N个正整数组成，这些数字表示电梯按照给定的顺序停留的楼层号。

电梯升一层花费6秒钟，降一层花费4秒钟，并且每次停留花费5秒钟。

对于每一份任务表，你要计算出完成全部升降任务所花费的总时间。一开始，电梯在第0层，并且最终完成任务时电梯不必一定返回到0层。

## 输入

第1行是一个整数T，表示随后有T组数据。

每组数据包含1个正整数N，以及N个正整数。

## 输出

对每组数据，输出总时间，并换行。

## 样例

| 输入  | 输出 |
| ----- | ---- |
| 2     |      |
| 1     |      |
| 2     |      |
| 3     | 17   |
| 2 3 1 | 41   |

## 解析

```C
#include <stdio.h>

int main(void)
{
    int T = 0;
    int i = 0;

    scanf("%d", &T); // T组数据
    for (i = 0; i < T; i++)
    {
        int j = 0;
        int N = 0;             // N个正整数
        int current_floor = 0; // 初始楼层为0
        int total_time = 0;

        scanf("%d", &N);
        for (j = 0; j < N; j++)
        {
            int last_floor = current_floor; // 定义一个变量存储上一次的楼层数

            scanf("%d", &current_floor);
            if (current_floor > last_floor) // 用选择语句进行比较，并计算时间
                total_time += (current_floor - last_floor) * 6 + 5;
            else if (current_floor < last_floor)
                total_time += (last_floor - current_floor) * 4 + 5;
        }
        printf("%d\n", total_time); // 打印出总时间
    }

    return 0;
}
```

# 24.最大公约数

## 描述

输入两个正整数m和n，输出m和n的最大公约数。

## 输入

第1行是一个整数T，表示随后有T组数据。每组数据占一行，包含两个整数，用空格隔开。

## 输出

对每组数据输出两个整数的最大公约数，并换行。

## 样例

| 输入 | 输出 |
| ---- | ---- |
| 3    |      |
| 2 5  | 1    |
| 4 6  | 2    |
| 3 9  | 3    |

## 解析

```c
#include <stdio.h>

int main(void)
{
    int T = 0, i = 0;

    scanf("%d", &T);
    for (i = 0; i < T; i++)
    {
        int m = 0, n = 0, a = 0;

        scanf("%d %d", &m, &n);
        while (a = m % n) // 通过辗转相除法来求最大公约数，当取模为0时跳出循环
        {
            m = n; // 将n赋给m
            n = a; // 将取模的结果a赋给n，而后下一次循环计算n%(m%n)的结果
        }          // 跳出循环后，此时的除数就是最大公约数
        printf("%d\n", n);
    }

    return 0;
}
```

# 25.求两个整数之间的倒数和

## 描述

给定两个整数，求解这两个整数范围内的所有整数的倒数的总和。注意遇到整数0时，直接加上0。

## 输入

第1行是一个整数n，表示随后有n组数据。每组数据占一行，包含2个整数，a,b，用空格隔开。

## 输出

对每组数据输出范围（包含边界整数）之间相应的倒数和，要求保留三位小数，并换行。

## 样例

| 输入 | 输出  |
| ---- | ----- |
| 3    |       |
| 1 1  | 1.000 |
| 2 0  | 1.500 |
| -1 1 | 0.000 |

## 解析

```c
#include <stdio.h>

int main(void)
{
    int n = 0, i = 0;

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        int a = 0, b = 0, min = 0, max = 0;
        float sum = 0.0f;

        scanf("%d %d", &a, &b);
        if (a > b) // 判断a、b是最小值和最大值
            max = a, min = b;
        else
            max = b, min = a;
        while (min <= max)
        {
            if (min == 0) // 当min为0时，加1然后跳过
            {
                min++;
                continue;
            }
            sum += 1.0 / min;
            min++;
        }
        printf("%.3f\n", sum); // 小数点后3位
    }

    return 0;
}
```

# 26. 鸡兔同笼

## 描述

鸡兔同笼，共有x个头，y只脚，求问鸡兔各有几只？（假设鸡兔都是健全的，且x,y>0）

## 输入

第一行是一个整数n，表示一共有n组测试用例；

下面一共有n组输入，每组输入为两个正整数，分别表示头和脚的数量，中间用空格隔开

## 输出

对于每一组输入数据，若数据合理（即有整数解），则分别输出鸡兔的数量，用空格隔开；若输入数据有问题，则输出error；每组输出单独占一行

##  样例

| 输入 | 输出  |
| ---- | ----- |
| 2    |       |
| 1 1  | error |
| 2 6  | 1 1   |

## 解析

$$
\begin{cases}
r+c=x\\
4r+2c=y
\end{cases}
$$

由此，得到：
$$
\begin{cases}
2r=y-2x\\
c=x-r
\end{cases}
$$
可知：

```c
#include <stdio.h>

int main()
{
    int n = 0;

    scanf("%d", &n);
    while (n) // 用n，减少一个变量i的创建
    {
        int x = 0, y = 0;

        scanf("%d %d", &x, &y);
        if ((y - 2 * x) % 2 != 0 || y - 2 * x < 0) // 由方程可知，该值必须为偶数和非负整数
            printf("error\n");
        else
        {
            int r = (y - 2 * x) / 2; // 定义兔子为r，鸡为c
            int c = x - r;           // 两式皆由公式而来

            if (r >= 0 && c >= 0)
                printf("%d %d\n", c, r); // 两个数都大于0
            else
                printf("error\n"); // 不符不输出
        }
        n--;
    }

    return 0;
}
```

# 27.第二小的整数

## 描述

找出整数序列中第二小的数。

## 输入

第1行是一个整数$n$，表示随后有$n$组数据。每组数据占一行，第一个整数$m$，1≤$m$≤100，表示随后有$m$个整数。

## 输出

对每组数据，输出第二小的数。如果第二小的数不存在，则输出`ERROR`。

## 样例

输入：

```
4
7 3 1 2 4 5 6 7
4 5 5 8 13
1 2
4 3 3 3 3
```

输出：

```
2
8
ERROR
ERROR
```

## 解析

```c
#include <stdio.h>

int main(void)
{
    int n = 0;

    scanf("%d", &n);
    while (n)
    {
        int m = 0, i = 0, min_2 = 0, arr[100] = {0};

        scanf("%d", &m);
        for (i = 0; i < m; i++)
        {
            scanf("%d", &arr[i]);
        }
        for (i = 0; i < m - 1; i++) // 用排序算法对数组内元素从小到大进行排序
        {
            int j = 0;

            for (j = 0; j < m - 1 - i; j++)
            {
                if (arr[j + 1] < arr[j])
                {
                    int temp = arr[j + 1];

                    arr[j + 1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        min_2 = arr[0]; // 假定min_2的值为最小值
        for (i = 0; i < m; i++)
        {
            if (arr[i] != arr[0])
            {
                min_2 = arr[i]; // 找到第一个不等于最小值的数,赋给min_2
                break;
            }
        }
        if (min_2 == arr[0]) // 如果还是等于最小值，输出“ERROE"
            printf("ERROR\n");
        else
            printf("%d\n", min_2);
        n--;
    }

    return 0;
}
```

# 28.统计二进制中1的个数

【题目内容】

写一个函数返回参数二进制中1的个数。

比如：15	0000 1111	4个1

```c
// 方法1，但是负数不可以
#include <stdio.h>

int count_num_of_1(int num)
{
    int count = 0;

    while (num)
    {
        if (num % 2 == 1)
            count++;
        num /= 2;
    }

    return count;
}

int main(void)
{
    int num = 0, n = 0;

    scanf("%d", &num);
    n = count_num_of_1(num);
    printf("%d\n", n);

    return 0;
}
```

```c
// 方法1（升级版）
int count_num_of_1(unsigned int num) // 进行小的改造，将有符号数转换为无符号数
{                                    // 比如-1，此时在函数中就被当成一个非常大的正数来进行计算
    int count = 0;									 // 虽然传的是有符号数，但是形参被当成无符号数来传参

    while (num)
    {
        if (num % 2 == 1)
            count++;
        num /= 2;
    }

    return count;
}
```

```c
// 方法2
int count_num_of_1(int num)
{
    int i = 0, count = 0;

    for (i = 0; i < 32; i++)
    {
        if ((num >> i) & 1 == 1) // 进行按位与1的操作，如果LSB是1，就++；每一次右移操作都会更新LSB来进行关系运算
            count++;
    }

    return count;
}
```

在介绍方法3前，先介绍：

```
n = 15;
n = n & (n - 1);
1111 n
1110 n - 1
1110 n
1101 n - 1
1100 n
1011 n - 1
1000 n
0111 n - 1
0000
```

上述方法可以看出`n & (n - 1)`的效果，当计算一次该式，就会使二进制数字的1少一个，循环的次数与1的个数相等，直至算到0。

这个式子是通过借位来实现少1的。

**最优解**，因此有：

```c
// 方法3
int c_count_num_of_1(int num)
{
    int count = 0;

    while (num)
    {
        num = num & (num - 1); // 计算该式
        count++; // 个数加一
    }

    return count;
}
```

同时，该式可以判断一个数是否为$2^n$，因为：

```
2 10
4 100
8 1000
16 10000
```

由此可知，在$2^n$中只有一位是1，因此：

```c
if (n & (n - 1) == 1)
{
}
```

可以写出这样的代码。

# 29.打印“X”图案

```c
#include <stdio.h>

int main(void)
{
    int n = 0, i = 0;

    while (scanf("%d", &n) == 1) // 这样可以满足多组输入,这是一种写法
    {
        for (i = 0; i < n; i++)
        {
            int j = 0;

            for (j = 0; j < n; j++)
            {
                if (i == j || i == n - 1 - j)
                    printf("*");
                else
                    printf(" ");
            }
            printf("\n");
        }
    }

    return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2Fa36620c59b6fa4dd94d0f2a16a6cba8a--2e39--image-20231104113622765.png" alt="image-20231104113622765" style="zoom:80%;" />

# 30.伪回文数

## 描述

输入一个正整数， 判断它是不是一个伪回文数。（回文数是顺着看和倒着看都一样的数，例如`1221`，`12321`都是回文数，伪回文数是改动一个数字就能变成回文数的数，1位数不是伪回文数）。

## 输入

第一行输入一个正整数$n$，表示下面有$n$组数据。
每组数据为一个正整数，能够用`int`保存，占用一行。

## 输出

对于每组数据，若是伪回文数，输出`yes`，否则输出`no`。

## 样例

输入

```shell
2
122
12321
```

输出

```
yes
no
```

## 解析

```c
#include <stdio.h>

int isPseudoPalindrome(int num) // 定义一个函数来判断伪回文数
{
    int orignal = num;   // 原始的数
    int reverse = 0;     // 反转的数
    int differCount = 0; // 不同位的个数

    while (num) // 回文数求法，不再赘述
    {
        reverse = reverse * 10 + num % 10;
        num /= 10;
    }
    if (orignal == reverse) // 为回文数必不为伪回文数
        return 0;           // 返回0代表假
    else
    {
        while (orignal)
        {
            if (orignal % 10 != reverse % 10)
                differCount++; // 计算反转数与原数不同位的个数
            orignal /= 10;
            reverse /= 10;
        }
    }                     // 值得注意的是，举例122,221，一共有两个不同的位（坑爹AI）
    if (differCount == 2) // 因此当不同位的个数为2时，返回1，代表真
        return 1;
    else
        return 0;
}

int main(void)
{
    int n = 0;

    scanf("%d", &n);
    while (n--)
    {
        int num = 0;

        scanf("%d", &num);
        if (isPseudoPalindrome(num)) // 调用函数，真则打印yes，假则打印no
            printf("yes\n");
        else
            printf("no\n");
    }
    return 0;
}
// 扩展：在C++中有动态数组的概念，可以利用动态数组来解决该问题
```

# 31.找子串

## 描述

请在输入的一段字符串里面查找给定的子串，找到后用`/* */`注释起来再输出。子串不区分大小写，即`one`、`One`和`ONE`是同一个子串。另外子串不会重叠出现。

## 输入

每个输入包含一个测试数据，第一行输入一行待查找的字符串，以回车结束。

第二行输入要查找的子串，以回车结束。字符串最长长度不超过 100100。

## 输出

如果找到子串，则在子串前面加`/*`，后面加上`*/`， 把子串(保持原样)注释起来再输出。没有找到就输出原字符串。

## 样例1

### 输入

```
You are the best!
are
```

### 输出

```
You /*are*/ the best!
```

## 样例2

### 输入

```
You are the best!
E
```

## 输出

```
You ar/*e*/ th/*e*/ b/*e*/st!
```

## 解析

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    int i = 0, j = 0;
    char str1[100] = {0};
    char str2[100] = {0};

    fgets(str1, 100, stdin);
    fgets(str2, 100, stdin);
    str1[strlen(str1) - 1] = '\0';  // 去掉末尾的'\n'
    str2[strlen(str2) - 1] = '\0';  // 去掉末尾的'\n'

    int len1 = strlen(str1);
    int len2 = strlen(str2);

    while (i < len1)
    {
        if (strncasecmp(&str1[i], str2, len2) == 0)
        {
            printf("/*%.*s*/", len2, &str1[i]);
            i += len2;
        }
        else
        {
            printf("%c", str1[i]);
            i++;
        }
    }

    return 0;
}
```

# 32.今天星期几

## 描述

已知1900年1月1日是星期一，问这天之后的任意一天是星期几？

## 输入

1900年1月1日以后的任一合法日期，格式为yyyy-MM-dd，如2000-01-01。

## 输出

输入日期所对应的星期。

## 样例

### 输入

2017-11-11

### 输出

Saturday

## 解析

```c
#include <stdio.h>

int zeller(int year, int month, int day) // 蔡勒公式
{
    if (month == 1 || month == 2) // 将1月和2月当成上一年的13、14月
    {
        month += 12;
        year--;
    }

    int c = year / 100;                                            // c代表世纪数
    int y = year % 100;                                            // 代表后两位数，如1949年中的49年
    int m = month;                                                 // 月份
    int d = day;                                                   // 日期
    int w = y + y / 4 + c / 4 - 2 * c + 26 * (m + 1) / 10 + d - 1; // 星期几为w%7

    if (w < 0) // 对负数的取模运算
        w = (w % 7 + 7) % 7;
    else
        w %= 7;

    return w;
}

int main(void)
{
    int year = 0, month = 0, day = 0;

    scanf("%d-%d-%d", &year, &month, &day);

    char *week[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    int result = zeller(year, month, day);

    printf("%s\n", week[result]);

    return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2Ff1e8d0ff875c9bcabecc552edf9d07f0--a5a2--image-20231114144703069.png" alt="image-20231114144703069" style="zoom: 80%;" />

# 33.喝汽水

喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，给20元，可以喝多少瓶汽水？

```c
#include <stdio.h>

int main(void)
{
    int money = 0;

    scanf("%d", &money);

    int total = money;
    int empty = money;

    while (empty / 2) // 当空瓶数大于1时才可以换
    {
        total += empty / 2;            // 剩的空瓶每两个换汽水，喝的汽水增加
        empty = empty / 2 + empty % 2; // 剩下的空瓶等于把上次剩的两个两个换了的加上没换的
    }
    printf("%d\n", total); // 打印出总瓶数

    return 0;
}
```

# 34.N皇后问题

## 描述

这是一道久违的正经题：

N皇后问题是一个经典的问题，描述如下：在 *N*∗*N* 的方格棋盘需要放置 *N* 个皇后，使得它们不相互攻击，即任意 22 个皇后不允许处在同一排、同一列，也不允许处在与棋盘边框成 45 度角的斜线上。

对于给定的 *N*，请输出有多少种合法的放置方法。

## 输入

多组数据，每组数据格式如下：

每行一个正整数*N*（0<*N*≤10），表示棋盘和皇后的数量。

## 样例

### 输入

```
8
```

### 输出

```
92
```

## 解析

```c
#include <stdio.h>

#define MAX_N 10

int count = 0; // 计数器

int is_safe(int board[MAX_N][MAX_N], int row, int col, int N) // 这是一个判断是否可以放置的函数
{
    int i = 0, j = 0; // 循环变量

    for (i = 0; i < row; i++) // 判断元素所在的这一列是否有皇后
        if (board[i][col] == 1)
            return 0;

    for (i = row, j = col; i >= 0 && j >= 0; i--, j--) // 判断左上角对角线是否有皇后
        if (board[i][j] == 1)
            return 0;

    for (i = row, j = col; i >= 0 && j < N; i--, j++) // 判断右上角对角线是否有皇后
        if (board[i][j] == 1)
            return 0;

    return 1; // 没有，说明可以放，返回1
}

void solve_NQueens(int board[MAX_N][MAX_N], int row, int N)
{
    int i = 0; // 循环变量

    if (row == N) // 如果所有行都被遍历过了，说明找到一种解法，++count
    {
        ++count;
        return;
    }

    for (i = 0; i < N; i++)            // 遍历该行所有列
        if (is_safe(board, row, i, N)) // 安全，可以放置
        {
            board[row][i] = 1;                // 放置
            solve_NQueens(board, row + 1, N); // 这一行没得放了，进入下一行
            board[row][i] = 0;                // 该种方法无论可行与否都将此位置重新设为0，进行下一种方案的讨论
        }
}

int main(void)
{
    int N = 0;
    int board[MAX_N][MAX_N] = {0};

    while (scanf("%d", &N) != EOF)
    {
        count = 0;
        solve_NQueens(board, 0, N);
        printf("%d\n", count);
    }

    return 0;
}
```

举例：2个N皇后，第一个放在第一行第一列，而后进入递归；检测第二行第一列，不能放置；检测第二行第二列，不能放置；此时row等于1，那个判断条件也不满足，该方案失败。退出递归后，将该位置设为0，进行下一列的判断。可知每一个可行方案第一行必有一个N皇后，所以每一次递归都从第一行开始。

# 35.字符串逆序（补完）

## 输入

```
I like Beijing.
```

## 输出

```
Beijing. like I
```

## 解析

```c
#include <stdio.h>
#include <string.h>

void swap(char *a, char *b) // 交换两个字符
{
    char temp = *a;

    *a = *b;
    *b = temp;
}

void reverse(char *leaf, char *right) // 逆序字符串用的函数
{
    while (leaf < right)
    {
        swap(leaf, right);
        leaf++, right--;
    }
}

int main(void)
{
    char str[101] = {0}; // 定义一个101大小的字符数组来放置

    fgets(str, 100, stdin); // 输入字符串
    str[strcspn(str, "\n")] = '\0';

    int len = strlen(str);       // 计算字符串的大小
    char *leaf = str;            // 定义整个字符串的左下标
    char *right = &str[len - 1]; // 右下标

    reverse(leaf, right); // 逆序整个字符串

    char *start = str; // 将子串的左下标定义为str[0]的地址

    while (*start) // 当首元素的地址不为0时，进行循环
    {
        char *end = start; // 定义右下标开始与左下标相同

        while (*end != ' ' && *end != '\0') // 当右下标不为0或者空格时，end++
            end++;
        reverse(start, end - 1); // 跳出循环，说明此时end指向的不为字符，end-1为子串最后一个字符
        if (*end != '\0')        // 如果此时end指向的不为字符串结束标志，那就进行下一个单词的逆序
            end++;
        start = end; // 将start赋值为end
    }
    printf("%s\n", str);

    return 0;
}
```

# 36.字符串排序

## 描述

输入一串字符串，按字母顺序的顺序将它们排序输出。

## 输入

输入多组测试数据（每组测试数据占一行），每组数据为一个字符串。

## 输出

当输入的字符串包含数字和字母之外的字符时，输出Input Error。否则，分别输出排序前后的字符串（排序的顺序为0~9、A~Z、a~z），换行输出。特别地，当输入为exit时，输出End Of Input，测试结束。

## 样例

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2Fe55e998acd964f2317cb926703b6676b--18df--image-20231121181514103.png" alt="image-20231121181514103" style="zoom:80%;" />

## 解析

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h> // 判断字符类型的函数所需的头文件

void swap_ch(char *a, char *b) // 交换字符的函数
{
    char temp = *a;

    *a = *b;
    *b = temp;
}

void bubble_sort_ch(char str[], int len) // 冒泡排序，因为这些字符在ASCII码中都是有序排放
{
    int i = 0, j = 0;

    for (i = 0; i < len - 1; i++)
    {
        for (j = 0; j < len - 1 - i; j++)
        {
            if (str[j] > str[j + 1])
                swap_ch(&str[j], &str[j + 1]);
        }
    }
}

int main(void)
{
    int flag = 1; // 判断是否有输入错误的变量
    char str1[100000] = {0};
    char str2[100000] = {0};

    while (1)
    {
        int i = 0;

        fgets(str1, 100000, stdin);        // 输入的函数
        str1[strcspn(str1, "\n")] = '\0';  // 因为末尾的'\n'也会进去，所以换成结束标志，而strcspn是找相应字符位置的函数
        for (i = 0; i < strlen(str1); i++) // 便历整个数组1
        {
            if (isalnum(str1[i]) == 0) // 发现不符字符，将判断的那个变量赋值为0
                flag = 0;
        }
        if (strcmp(str1, "exit") == 0) // 判断这个字符是否和退出字符相等
        {
            printf("End Of Input\n");
            break;
        }
        else if (flag == 0) // 判断输入对错
        {
            printf("Input Error\n");
            flag = 1; // 重新定义为1，进行下一次循环
            continue; // 跳过下列循环
        }
        strcpy(str2, str1);                 // 将字符串1拷贝到字符串2
        bubble_sort_ch(str2, strlen(str2)); // 将字符串2的顺序给排了
        printf("%s\n%s\n", str1, str2);     // 输出
    }

    return 0;
}
```

# 37.字符串匹配

## 描述

给定字符串A和字符串B，求字符串B第一次在字符串A中出现的位置。（字符串长度不超过1000个字符）

## 输入

第1行是一个整数N，表示有N组测试数据，接着是各组测试数据的字符串A和字符串B。

## 输出

对每组测试数据输出字符串B第一次出现在字符串A中的位置，并换行。

## 样例

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2F9f7d4ab9349ef61c3d2cb2e388ecaba3--2726--image-20231121230852008.png" alt="image-20231121230852008" style="zoom: 80%;" />

## 解析

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    int i = 0, n = 0;
    char str1[1001] = {0};
    char str2[1001] = {0};

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        scanf("%s %s", str1, str2);
        printf("%d\n", strstr(str1, str2) - str1 - 1); //  strstr函数返回在str1找到的第一个的str2的首字符地址
    } // 将该首字符地址减去str1的首字符地址再减去1，就是它所谓的在str1的位置

    return 0;
}
```

# 38.倒序打印字符串

## 描述

给你一个长度<=100字符串，倒序打印它。**以"]"结束, "]"不需要打印.**

包括数字（0-9），字母（'A'-'Z', 'a'-'z'），空白（换行'\n'以及空格）。

## 输入

一个长度<=100的字符串。

## 输出

倒序输出字符串。

## 样例

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2Fb96eb9a528e7a4dc4b4d56bc06ea23f0--7b0f--image-20231121231346340.png" alt="image-20231121231346340" style="zoom:80%;" />

## 解析

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    int i = 0;
    char ch = '\0';
    char str[101] = {0};

    while ((ch = getchar()) != ']')
    {
        str[i] = ch; // 将该字符赋给字符串中的相应
        ++i;         // 下标++，看下一个元素
    }
    for (i = strlen(str) - 1; i >= 0; i--)
    {
        printf("%c", str[i]);
    }

    return 0;
}
```

# 39.字符串合并

## 描述

现有两个字符串，请将两个字符串中的非数字和非字母的字符去掉，并将剩下的字符串合并成一个新的有序（按照ASCII码序升序）字符串，并打印合并后的字符串。

**注：输入的每个字符串中不包含换行符、空白符或缩进符**

## 输入

两个字符串。

## 输出

合并后的字符串。

## 样例1

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2F9459b0aa9061a3f2c1ea81a8c262bfd5--9659--image-20231121231622128.png" alt="image-20231121231622128" style="zoom:80%;" />

## 样例2

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2F8e1f56f035fe0c18b2bbc2c6aa50cd40--013e--image-20231121231644643.png" alt="image-20231121231644643" style="zoom:80%;" />

## 答案

```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

void swap_ch(char *a, char *b)
{
    char temp = *a;

    *a = *b;
    *b = temp;
}

void bubble_sort_ch(char str[], int len)
{
    int i = 0, j = 0;

    for (i = 0; i < len - 1; i++)
    {
        for (j = 0; j < len - 1 - i; j++)
        {
            if (str[j] > str[j + 1])
                swap_ch(&str[j], &str[j + 1]);
        }
    }
}

int main(void)
{
    int i = 0, j = 0;
    char str1[10001] = {0};
    char str2[10002] = {0};

    fgets(str1, 10001, stdin);
    str1[strcspn(str1, "\n")] = '\0';
    for (i = 0; i < strlen(str1); ++i)
    {
        if (isalnum(str1[i])) // 判断该字符是否符合
        {
            str2[j] = str1[i]; // 若符合放在数组2，同时数组2的下标++
            ++j;
        }
    }
    bubble_sort_ch(str2, strlen(str2)); // 排序字符串
    printf("%s\n", str2);

    return 0;
}
```

# 40.奇偶数交换

```c
#include <stdio.h>

void move_arr(int arr[], int sz) // 交换奇偶位置的函数，将奇数放在数组前面，偶数放在数组后面
{
    int l = 0, r = sz - 1; // 定义左右下标

    while (l < r) // 当左下标小于右下标时，执行循环
    {
        while (l < r && arr[l] % 2 == 1) // 之所以加上l<r的条件是为了防止数组越界
        {
            l++;                         // 取模为1的时候，说明该元素是奇数，可以放在前面，那就跳过
        }                                // 循环停止的时候，说明遇到偶数了
        while (l < r && arr[r] % 2 == 0) // 右下标，同理
        {
            r--;
        }

        if (l < r) // 交换这两个元素
        {
            int tmp = arr[l];
            arr[l] = arr[r];
            arr[r] = tmp;
            l++, r--; // 交换完后进入下一个元素的交换
        }
    }
}

int main(void)
{
    int i = 0;
    int arr[10] = {0};
    int sz = sizeof(arr) / sizeof(arr[0]);

    for (i = 0; i < sz; i++)
    {
        scanf("%d", arr + i);
    }

    move_arr(arr, sz);
    for (i = 0; i < sz; i++)
    {
        printf("%d ", arr[i]);
    }

    return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-27%2F4042fb9a04c90c50a399cb7a05f77c71--af2c--image-20231127175022739.png" alt="image-20231127175022739" style="zoom: 80%;" />

# 41.二义性编**描述**

## 描述 

有一个消息包含A~Z，消息通过以下规则编码：

  **A——>1，B——>2……Z——>26。**

给你一个加密过后的信息，求有多少种解码方式（加密过后的信息不超过70个字符）。

## 输入

第1行是一个整数N，表示有N组测试数据，接着是各组测试数据的字符串。

eg:12

## 输出

对每组测试数据输出解码方式。

2 因为12有（AB,L）2中解码方式

## 样例

| 输入 | 输出 |
| ---- | ---- |
| 2    |      |
| 12   | 2    |
| 123  | 3    |

## 解析

```c
#include <stdio.h>
#include <string.h>

int num_decoding(char *str)
{
    int i = 0;
    int len = strlen(str);
    int dp[71] = {0}; // 该数组存储到第i个位置时（注意：不是i-1），前i个元素解码方式的个数

    dp[0] = 1;                     // i=0，为空字符串，假设空字符串有一种解码方式（便于解体）
    dp[1] = 1;                     // 第一个字符的解码方式先假设为1（不管第1个字符是否为'0'）
    if (len == 0 || str[0] == '0') // 当字符串为空字符串或者第一个字符为字符'0'
        return 0;                  // 0种解码方法
    for (i = 2; i <= len; i++)     // 如果第一个字符有解码方式，那就从第二个字符开始计算数量
    {
        int one_digit = str[i - 1] - '0';                    // 定义一位数，存储当前位置的数字字符转换的数值
        int two_digit = (str[i - 2] - '0') * 10 + one_digit; // 定义两位数，存储当前位置和前一个位置组成转换后的数值
        // 注意：dp[i]代表第i个位置，str[i - 1]代表第i个位置
        if (one_digit >= 1)     // 当这个数大于1时
        {                       // 如果当前位置满足一个数的解码方式，那么它与前n个数
            dp[i] += dp[i - 1]; // 说明它至少有与前一位的数共组的dp[i - 1]种解码方式
        }
        if (two_digit >= 10 && two_digit <= 26) // 当这个数大于10且小于26时
        {                                       // 如果当前位置和前一个位置满足两个数的解码方式
            dp[i] += dp[i - 2];                 // 说明它至少有与前两位的数共组的dp[i - 2]种解码方式
        }                                       // 此时要把当前位置的字符与前一个位置的字符当成一个整体来与前面的字符组成新的解码方式
    }

    return dp[len];
}

int main(void)
{
    int n = 0, i = 0;
    char str[71] = {0};

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        scanf("%s", str);
        printf("%d\n", num_decoding(str));
    }

    return 0;
}
```

# 42.考试成绩单

## 描述

有n个学生成绩信息（包括学号、姓名、语文成绩、英语成绩、数学成绩、总成绩）要求算出总成绩、并按照总成绩排名输出，总成绩相同，按照姓名的字典序输出。

定义结构体入下：

```c
struct student
{
  char name[21];//姓名

  int sno;//学号

  double chinese;//语文

  double english;//英语

  double math;//数学

  double sum;//总成绩
};
```

## 输入

第1行是一个整数N，表示有N个学生信息，接着是各个学生的信息。（注：学生信息按照姓名，学号，语文成绩、英语成绩、数学成绩的顺序输入，各个数据之间空格隔开）

## 输出

学生信息排序之后输出

## 样例

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-05%2F26a245f0360bd4c4f5fde6f662640815--6bf3--image-20231205202036308.png" alt="image-20231205202036308" style="zoom:80%;" />

## 解析

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct student
{
    char name[21];
    int sno;
    double chinese;
    double english;
    double math;
    double sum;
}; // 题目给定的结构体

int cmp_struct(const void *e1, const void *e2) // qsort所需的比较函数
{
    struct student *stu1 = (struct student *)e1; // 将强制类型转换后的值赋给新的变量
    struct student *stu2 = (struct student *)e2;

    if (stu1->sum != stu2->sum)                    // 当两者的总分不相等时
        return stu1->sum - stu2->sum > 0 ? -1 : 1; // 当前者小于后者，返回-1，代表降序，因为返回1代表升序
    else
        return strcmp(stu1->name, stu2->name); // 两者相等，返回那个字符串比较
} // strcmp可以通过姓名字典序来排，若前者大于后者，返回1；前者小于后者，返回-1

int main(void)
{
    int n = 0;
    int i = 0;
    struct student s[10000];

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        scanf("%s %d %lf %lf %lf",
              s[i].name, // 注意第一个输入的元素是字符串，
              &s[i].sno, // 其余要进行取地址操作
              &s[i].chinese,
              &s[i].english,
              &s[i].math);
        s[i].sum = s[i].chinese + s[i].english + s[i].math; // 算出总数
    }

    qsort(s, n, sizeof(s[0]), cmp_struct); // 用qsort函数进行排序
    for (i = 0; i < n; i++)
    {
        printf("[name:%s,sum:%d,sno:%d]\n",
               s[i].name,
               (int)s[i].sum,
               s[i].sno); // 打印
    }

    return 0;
}
```

# 43. 求给定范围内的素数

## 描述

输入一个正整数n,求出小于等于该正整数的所有素数。

## 输入

正整数（n<=10000）。

## 输出

小于等于输入整数n所有素数，每个素数之间以空格分割，输出结束后换行。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-05%2Ffb134b24cc97a5b3af290a38943ec205--12fc--image-20231205203748940.png" alt="image-20231205203748940" style="zoom:80%;" />

## 解析

```c
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

bool is_prime(int num)
{
    int i = 2; 

    for (i = 2; i <= sqrt(num); i++) // 如果这个数不是素数
    { // 它的其中一个因子必小于等于它的平方根
        if (num % i == 0) // 如果存在一个数使得这个数能不被整除
            return false; // 该数不是素数
    }

    return true; // 否则该数是素数
}

int main(void)
{
    int i = 0;
    int n = 0;

    scanf("%d", &n);
    for (i = 2; i <= n; i++)
    {
        if (is_prime(i))
            printf("%d ", i);
    }
    printf("\n");

    return 0;
}
```

## 拓展

> 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定1既不是质数也不是合数）。

# 44.字符串排序

## 描述

输入4个字符串，先将它们排序输出；再输入一个字符串，重新排序输出。

 ## 输入

先输入4个字符串，然后再输入一个字符串，将5个字符串重新排序并输出。

注意：每个字符串占一行，且每个字符串不大于20个字符

## 输出

将先输入的4个字符串按ASCII码顺序排序并输出；再将插入新字符串后的5个字符串排序并输出。

注意：插入前后的字符串空一行

##  样例

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-07%2F9efec8387d80a3f9ed9d2491a7179f9a--aeb9--image-20231207193218994.png" alt="image-20231207193218994" style="zoom:80%;" />

## 解析

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int cmpStr(const void *e1, const void *e2)
{
    return strcmp(*(char **)e1, *(char **)e2); // 这个比较函数传进去的是数组每个元素的地址
    // 而每个元素又是一个地址，所以这个指针要被强制类型转换为二级指针，然后解引用得到每个字符串的首元素地址
    // 之后作为参数输入strcmp函数进行比较
}

int main(void)
{
    char str1[21] = {0};
    char str2[21] = {0};
    char str3[21] = {0};
    char str4[21] = {0};
    char str5[21] = {0};
    char *arr[5] = {str1, str2, str3, str4, str5};

    for (int i = 0; i < 4; i++)
    {
        scanf("%s", arr[i]);
    }

    qsort(arr, 4, sizeof(arr[0]), cmpStr);
    for (int i = 0; i < 4; i++)
    {
        printf("%s\n", arr[i]);
    }
    printf("\n");

    scanf("%s", arr[4]);
    qsort(arr, 5, sizeof(arr[0]), cmpStr);
    for (int i = 0; i < 5; i++)
    {
        printf("%s\n", arr[i]);
    }

    return 0;
}
```

# 45.猜名次

题目名称：
猜名次
题目内容
5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果
A选手说：B第二，我第三
B选手说：我第二，E第四；
C选手说：我第一，D第二；
D选手说：C最后，我第三；
E选手说：我第四，A第一；
比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。

```c
#include <stdio.h>

int main(void)
{
    int a = 0;
    int b = 0;
    int c = 0;
    int d = 0;
    int e = 0;
    int arr[10] = {1, 2, 4};

    for (a = 1; a <= 5; a++)
    {
        for (b = 1; b <= 5; b++)
        {
            for (c = 1; c <= 5; c++)
            {
                for (d = 1; d <= 5; d++)
                {
                    for (e = 1; e <= 5; e++)
                    {
                        if ((b == 2) + (a == 3) == 1 && ((b == 2) + (e == 4) == 1) && ((c == 1) + (d == 2) == 1) &&
                            ((c == 5) + (d == 3) == 1) && ((e == 4) + (a == 1) == 1))
                        {
                            if (a * b * c * d * e == 120)
                            {
                                printf("a = %d, b = %d, c = %d, d = %d, e = %d\n", a, b, c, d, e);
                            }
                        }
                    }
                }
            }
        }
    }

    return 0;
}
```

运用穷举法，把每种情况列举出来。外层的那个`if`语句可以判断一半真并且一半假（因为如果两个都为真，放回2；都为假，返回0）；但是还有一些重复名次的情况，因此再加上一个判断条件（`a * b * c * d *e`等于`1 * 2 * 3 * 4 * 5`）。

# 46.猜凶手

题目内容
日本某地发生了一件谋杀案，警察通过排查确定杀人区手必为4个嫌疑犯的一个
以下为4个嫌疑们的供词
A说：不是我
B说：是C。
C说：是D。
D说：C在胡说
已知3个人说了真话，1个人说的是假话
现在请根据这些信息写一个程序来确定到底谁是凶手。

```c
#include <stdio.h>

int main(void)
{
    int killer = 0;

    for (killer = 'a'; killer <= 'd'; ++killer)
    {
        if ((killer != 'a') + (killer == 'c') + (killer == 'd') + (killer != 'd') == 3)
        {
            printf("%c", killer);
        }
    }

    return 0;
}
```

# 47.杨辉三角

```c
#include <stdio.h>

#define MAX_LEN 10

int main(void) {
  int arr[MAX_LEN][MAX_LEN] = {0};
  int n = 0;

  scanf("%d", &n);

  for (int i = 0; i < n; i++) {
    for (int j = 0; j <= i; j++) {
      if (j == 0 || j == i) {
        arr[i][j] = 1;
      } else {
        arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
      }
    }
  }

  for (int i = 0; i < n; i++) {
    for (int j = 0; j <= i; j++) {
      printf("%-4d", arr[i][j]);
    }
    printf("\n");
  }

  return 0;
}
```

# 48.左旋字符串

# 49.只出现两次的数

### 描述

输入 *n* 个整数，找出输入的整数中只出现 22 次的数。

### 输入

每个输入包含一个测试用例，第1行输入整数 *n* (1≤*n*≤20)；第2行输入 *n* 个整数，之间用空格分隔。

### 输出

输出只出现2次的整数，存在多个则用空格分隔，按首次出现的顺序输出。如果没有，则输出`none`。

### 样例1

输入

```
5
5 2 3 4 3
```

输出

```
3
```

### 样例2

输入

```
6
2 3 3 2 5 6
```

输出

```
2 3
```

### 样例3

输入

```
4
3 4 5 6
```

输出

```
none
```

### 答案

```c
#include <stdio.h>

int main(void) {
  int flag = 1;
  int n = 0;
  int count[21] = {0};

  scanf("%d", &n);
  int arr[n];

  for (int i = 0; i < n; ++i) {
    scanf("%d", &arr[i]);
    count[arr[i]]++;
  }

  for (int i = 1; i <= n; ++i) {
    if (count[i] == 2) {
      printf("%d ", i);
      count[i] = 0;
      flag = 0;
    }
  }

  if (flag) {
    printf("none\n");
  } else {
    printf("\n");
  }

  return 0;
}
```







