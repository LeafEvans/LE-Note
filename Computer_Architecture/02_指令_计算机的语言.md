# MIPS-32 概述

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250105115945638.png" alt="image-20250105115945638" style="zoom: 80%;" />

## 指令的组成——MIPS 的设计思想

计算机执行任何程序，本质上都是在执行机器语言**指令（instruction）**每条指令都是一条 0-1 串。

指令首先需明确执行何种操作，通常用 0-1 串的前几位来表示，通常称为**操作码**。

指令还要指出需要操作的数据来自哪里、操作后的结果数据放回哪里，此时通常用 0-1 串中的剩余位来表示，称为**操作数**或**地址码**。

大部分操作数都是一个地址编号，告诉 CPU 从哪里取得数据、向哪里放回数据，所以操作数通常也叫做地址码。

| 操作码 | 地址码 | 地址码 |
| :----: | :----: | :----: |

MIPS 作为一种 RISC 指令集，设计力求保证硬件设备的简单性。在 32 位 MIPS 汇编语言（MIPS-32）中，所有指令都是 32 位长。

## MIPS-32 中的通用寄存器

MIPS 中运算操作的操作数必须来自**寄存器（register）**或者指令本身。（*寄存器是一种位于 CPU、比 cache 更小更快的存储器，用来暂时存放运算的源数据和结果。*）

一些寄存器是专用的，如存放执行中指令的地址的**程序计数器（PC）**；与此相对应，用于暂时存放运算数据的寄存器称为通用寄存器。

MIPS 中一共有 32 个 32 位的寄存器，共 128B（大部分架构都采用 16 或 32 个寄存器）。

约定：

程序中的变量存放在**保存寄存器（store reg）**中：`$s0`~`$s7` 共 8 个。

运算的临时变量、中间变量存放在**临时寄存器（temp reg）**中：`$t0`~`$t7` 共 8 个。

还有一个**零寄存器**，永远存放 32 位的 0，写作 `$zero`。

# 三类汇编指令

## 算术运算：加 `add`、减 `sub`

C 赋值语句：

```c
c = a + b;
```

加法指令：将 `a` 和 `b` 中的数据相加，并将结果存放在 `c` 中。

```assembly
add c, a, b
```

再次强调：MIPS 中运算的操作数必须来自寄存器或者指令本身。

假设变量 a，b，c 分别存放在 `$s0`，`$s1`，`$s2` 中，这条指令就应当写为：

```assembly
add $s2, $s0, $s1
```

加法中两个加数可以对换，但减法不行，故 `c = a - b` 必须写作：

```assembly
sub $s2, $s0, $s1
```

运算的“原材料”，a 和 b 对应的寄存器 `$s0`，`$s1`，分别称为源操作数 1（src1）和源操作数 2（src2）运算的结果 c 对应的寄存器 `$s2` 称为目的操作数（des）。加减指令的通式：

```assembly
add/sub des, src1, src2
```

## 算术运算：加立即数 `addi`

在 `i++` 即 `i = i + 1`；这条赋值语句中，有个确定的常数 1，与其采取额外的步骤将 1 装入某个寄存器，不如让指令本身包含这个 1。

假设变量 `i` 位于寄存器 `$s0`，我们把加法指令的第二个源操作数改为常数 1：

```assembly
addi $s0, $s0, 1
```

此为加立即数（add immediate）指令。因为 `addi` 指令中的立即数可以取负数（对立即数取负后相加）。因此，MIPS 中没有 `subi` 指令。

## 逻辑按位运算：`and`、`or`、`nor` 指令

当两个源寄存器中，对应的位上同时为 1 时，与 `and` 操作结果为 1。

当两个源寄存器中，又对应的位上至少有一个为 1 时，或 `or`操作结果为 1。

因此，假设：

```assembly
$t0 = 0000 0000 0000 0000 0000 0000 0000 1001
$t1 = 0000 0000 0000 0000 0000 0000 0000 1100
```

<u>执行下列两条指令后，`$t2` 中的数据分别变为多少？</u>

```assembly
and $t2, $t0, $t1  # 0000 0000 0000 0000 0000 0000 0000 1000
or $t2, $t0, $t1   # 0000 0000 0000 0000 0000 0000 0000 1101
```

任何数据与 0 进行或非 `nor` 操作，都会 0/1 反转。

<u>执行下列指令后，`$t2` 中的数据会变为多少？</u>

```assembly
nor $t2, $t0, $zero  # 1111 1111 1111 1111 1111 1111 1111 0111
```

## 逻辑移位运算：`sll` 和 `srl` 指令

比较 12 和 120 两个十进制数，通过在最低位的右边添加一个 0，变为了 10 倍。

比较 11 和 110 两个二进制数，通过在最低位的右边添加一个 0，变为了多少倍？1100 呢？

**逻辑左移（shift left Iogic）**指令让寄存器中的数据整体往左移动指定的位数，并在右边空出来的位上补 0。（可以模拟乘 2 运算）

假设：

```assembly
$s2 = 0000 0000 0000 0000 0000 0000 0000 0101
```

逻辑左移两位后，放到寄存器 `$s0` 中：

```assembly
sll $s0, $s2, 2
```

这里的 2 不是 `addi` 指令中的立即数，而是告诉计算机移动几位的**移位量（shift amount）**。

通过这样一句指令，我们实际上完成了乘 4 的运算！

> `srl` 指令当然可以实现除 2 运算，使用场景不多，不额外讨论。

## 综合练习（一）

翻译一下 C 语句：

```c
result = a - 10 + (b + c * 5);
```

使用 `$s0` 表示 `a`，`$s1` 表示 `b`，`$s2` 表示 `c`，而 `$s3` 表示 `result`；则对应有：

```assembly
sll $t0, $s3, 2     # t0 = 4 * 2
add $t1, $t0, $s3   # t1 = 5 * c
add $t2, $t1, $t0   # t2 = b + 5 * c
addi $t3, $s0, -10  # t3 = a - 10
add $s3, $t3, $t2   # s3 = t2 + t3
```

## 寄存器-存储器数据传送：`Iw` 指令

运算指令的操作数必须来自于寄存器/指令本身；但是，通用寄存器一共只有 128B；数组元素却可以占据成千上万个字节，只能存放在内存中。

这时，我们把数组第一个元素（`a[0]`）的 32 位地址，称为数组的**基址**，放在寄存器中。基址加上要找的元素的下标，就组成了这个元素的地址。

如果源操作数在内存中，是数组 a 的 5 号元素（第六个元素），数组 a 的基址存放 `$s1` 中，那么，`a[5]` 的地址就表示为 `5($s1)`。计算机会自动计算 `$s1` 中的基址和**偏移量** 5 的和，找到 `a[5]` 的地址。

将 `a[5]` 从内存传送到寄存器 `$s0`，使用**取字指令（load word）**：

```assembly
lw $s0, 5($s1)
```

（还是有问题，详见下一部分）

## 寄存器-存储器数据传送：字与 `sw` 指令

MIPS 的通用寄存器都是 32 位长。这个长度就是 MIPS 体系结构的**字长**，通常代表了参与运算的数据的长度
因此我们约定：此门课程中，`1 word = 32b = 4B`。

`a[5]` 相对于 `a[0]` ，在内存中的距离是 5 个字，而不是 5 个字节。又因为内存<u>按字节编址</u>，即，内存每个字节都有一个特定的编号；所以偏移量应该是 5 x 4 = 20 个字节，`a[5]` 的地址应表示成 `20($s1)`。于是取数指令变为：

```assembly
lw $s0, 20($s1)
```

如果我们要把 `$t0` 中的运算结果送回内存中的 `a[2]`，需要用到**存字指令（store word）**：

```assembly
SW $t0, 8($s1)
```

## 寄存器间数据传送、装载立即数到寄存器

如果我们需要把数从 `$t0` 保存到存放某变量的 `$s1` 中，怎么实现？

MIPS 没有专门的寄存器间移动数据的指令。但是，通过把源寄存器中的数据加上 0 再保存到目标寄存器中，可以实现相同的功能：

```assembly
addi $s1, $t0, 0 # 
add $s1, $t0, $zero
```

这个功能可以用 **`move` 伪指令**来替代：

```assembly
move $s1, $t0
```

假如我们要把一个常数 10 装入寄存器 `$s2`，同样可以采用 `addi` 指令：

```assembly
add $s2, $zero, 10
```

或使用**取立即数（load immediate）**伪指令：

```assembly
li $s2, 10
```

## 装载 32 位立即数到寄存器

我们说可以用 `addi` 指令向寄存器装载立即数：`addi $s2，$zero，10`。

但是，`addi` 指令中的立即数 10 只能占用 32 位指令中的一部分；16 位只能表示 2E16，即六万多个数，寄存器却能容纳 2E32，即 40 多亿个数。

假设我们要向寄存器 `$s2` 装载一个 32 位的立即数：`10A2 7FFF`。

我们必须先用**取高位立即数（load upper immediate）**指令，把 `10A2` 放入 `$s2` 的高 `16` 位：

```assembly
lui $s2，4258  #十六进制的 10A2 等于十进制的 4258
```

执行完上述指令会将低 16 位置为 0，再让 `$s2` 与低 16 位的立即数 `7FFF` 进行或运算：

```assembly
ori $s2, $s2, 32767
```

这样，就分两步把 32 位立即数装载到了 32 的寄存器中。

> 不能使用 `addi` 替代 `ori` 指令，如果低 16 位的最高位是 1，`addi` 会把它理解为负数。

## 综合练习（二）

```C
a[i] = a[0] + 100000;
```

假设