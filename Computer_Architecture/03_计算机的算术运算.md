# 计算机的算术运算

## 整数的表示

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106100540601.png" alt="image-20250106100540601" style="zoom:67%;" />

### 无符号整数、原码、反码

不同于 MIPS 的 32 位字，先讨论 8 位整数简化处理。

将全部 8 位用来表示绝对值的二进制数叫做**无符号整数**，其表示范围为 0～+255（$2^8-1$）。

```assembly
00000000 00000001 00000010...11111111
```

将最高位用来表示正负号（正数为 0，负数为 1），其余 7 位表示绝对值的方法叫做**原码**。也称为**符号和幅值**表示法，其表示范围为 -127～-0～+0～127。

```assembly
00000000 00000001 00000010...01111111 10000000 10000001...11111111
```

> 原码是带符号整数的表示方法。

将最高位为 0 的原码按位取反来表示负数，叫做**反码**。其表示范围为 -127～-0～+0～+127（$2^7 - 1$）。

```assembly
00000000 00000001 00000010...01111111 11111111 11111110...10000000
```

### 补码、符号扩展、大小端编址

原码和反码不能直接用于二进制加减法，且正负两个 0 会给编程人员带来麻烦。因此，当今计算机都采用可以直接加减的**补码**来表示带符号整数。

先用 00000000～01111111 表示零和正整数 0～+127（$2^7-1$），再用 10000000～11111111 表示负数 -128（$-2^7$）～-1。

数 x 和它的反码相加，必定是 11111111（-1）。即 $x + \bar{x} = -1$，$\bar{x} + 1 = x$，因此将一个补码整数化为它的相反数，方法就是按位取反再加 1。

`addi` 指令中，第一个源操作数是 32 位补码寄存器，第二个源操作数是 16 位补码立即数。将*<u>最高位即符号位</u>*，复制到高 16 位，即可完成**符号扩展**。

对于一个长于 1 字节的整数，如果高位放在低地址，就称为**大端编址**；如果高位放在高地址，就称为**小端编址**。

已知 7 = 00000111，求：

1. -7 = 11111001；
2. 符号位为 0，因此拓展时使用 0；而 -7 符号位为 1，因此拓展时使用 1。

## 整数的四则运算、ALU

### 补码加减法、溢出

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106103346740.png" alt="image-20250106103346740" style="zoom:67%;" />

第二个式子（正 + 正 or 正 - 负）超出了 +127 的上限，对符号位产生进位，称为**上溢**。

第三个式子（负 - 正 or 负 + 负）超出了 -128 的下限，对符号位产生借位，称为**下溢**。

上溢和下溢统称为**<u>溢出</u>**，表现为对符号位进位或借位，符号错误。

### 数字逻辑电路

与门和或门具有两个或更多输入。**与门**“全 1 得 1”，写作 $\cdot$；**或门**“见 1 得 1”，写作 $+$。**非门**（又称**反相器**）只有一个输入，对输入取逆。对与门和或门的输入/输出取反时，<u>可打圆圈代替</u>。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106103700190.png" alt="image-20250106103700190" style="zoom:67%;" />

通过列举出逻辑电路中所有输入对应的输出情况，可以构建第一种逻辑表达方式：**真值表**。

通过给出左为一个输出、右为输入的逻辑等式，可以构建第二种逻辑表达方式：**逻辑方程（组）**。

### 多路选择器

>  译码器（decoder）有 $n$ 个输入和 $2^n$ 个输出，根据输入的数字将一个输出信号置位 1。

**多路选择器（multiplexer）**有 $n$ 个输入数据和 $1$ 个输出数据。根据**选择控制信号**的数字，决定将哪一个输入作为输出。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106104129449.png" alt="image-20250106104129449" style="zoom:50%;" />

四位的多路选择器如下：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106104501771.png" alt="image-20250106104501771" style="zoom:80%;" />

### 32 位 ALU：行波进位

将 32 个 1 位 ALU 拼接起来就形成了 **32 位 ALU**，低位的进位输出指向高位的进位输入，最低位的进位输入用于控制减法。

![image-20250106175305886](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106175305886.png)

### 32 位 ALU：超前进位

进位速度制约了加法的速度，32 位 ALU 的行波进位方式意味着每次进位都要通过*<u>与门、或门</u>*各一次，共产生 64 个**门延迟**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106175643625.png" alt="image-20250106175643625" style="zoom:67%;" />

为了加快进位、进而加快加法运算，现在广泛采用**超前进位加法器（carry-lookahead adder）**。通过将进位分为 4 位一组，抽象成每组的进位，实现加法器的并行执行。

<u>要执行 n 位加法，求出 n 是 4 的几次方并向上取整，再乘 2 加 1，就是超前进位的门延迟。</u>

以 16 位、64 位、32 位加法为例分析，并计算加速比：

16 位，$16 = 4^2$，因此门延迟为 $2 + 1 = 3$；64 位，$64 = 4^4$，因此门延迟为 $4 \times 2 + 1 = 9$；32 位，无法为 4 的整数幂，向上取整后有 3，因此门延迟为 $3 \times 2 + 1 = 7$，其加速比为 $\dfrac{64}{7}$。

### 乘法

列四位二进制竖式计算 $2 \times 3$。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106182930637.png" alt="image-20250106182930637" style="zoom:50%;" />

教材将前一个乘数称为**被乘数**，后一个称为**乘数**；被乘数乘以乘数某位的结果称为**中间积**；二进制的中间积要么是被乘数及其左移后的结果，要么是 0。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106182802098.png" alt="image-20250106182802098"  />

### 乘法器

两 32 位数相乘，乘数用 **32 位的乘数寄存器**即可；被乘数从低 **32 位**逐次到高 32 位，需要 **64 位**被乘数寄存器。而积最大位数有：
$$
\text{积最大位数} = \text{被乘数位数} + \text{乘数的位数}
$$


因此需要 64 位积寄存器。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106183706292.png" alt="image-20250106183706292" style="zoom:80%;" />

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106183725354.png" alt="image-20250106183725354"  />

### 改进的乘法器

上述乘法器将三个步骤执行 32 轮，大约需要 100 个时钟周期，且寄存器空间浪费较大。

注意到每进行一轮迭代，乘积位数从 32 增长到 64，乘数位数从 32 减少到 0，合起来总是 64 位，可以拼接成一个 **64 位乘积/乘数寄存器**（乘积一开始在高 32 位，乘数在低 32 位）。

让<u>**积相对于被乘数右移**</u>（而不是被乘数相对于积左移），ALU 从 64 位缩减到 32 位改进后硬件规模大大减小，每一步可以仅占一时钟周期。

![image-20250106185021445](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106185021445.png)

| 迭代 |         步骤         | 被乘数 |  积/乘数  |
| :--: | :------------------: | :----: | :-------: |
|  0   |       initial        |  0010  | 0000/0011 |
|  1   | 1 → 积 = 积 + 被乘数 |  0010  | 0010/0011 |
|      |     积寄存器右移     |  0010  | 00010/001 |
|  2   | 1 → 积 = 积 + 被乘数 |  0010  | 00110/001 |
|      |     积寄存器右移     |  0010  | 000110/00 |
|  3   | 1 → 积 = 积 + 被乘数 |  0010  | 000110/00 |
|      |     积寄存器右移     |  0010  | 0000110/0 |
|  4   | 1 → 积 = 积 + 被乘数 |  0010  | 0000110/0 |
|      |     积寄存器右移     |  0010  | 00000110/ |

### 除法

列竖式计算 $\dfrac{7}{2}$。

在任何情况下，整数除法都要满足：

$$
\text{被除数} = \text{除数} \times \text{商} + \text{余数}
$$

而计算 $-\dfrac{7}{2}$ 时，可以商 -3 余 -1，也可以商 -4 余 1。
为了避免这种差异，规定余数和被除数同号，即商 -3 余 -1。


![image-20250106191229588](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106191229588.png)

### 除法器

被除数一开始存在 64 位余数寄存器中，除数从 64 位除数寄存器的高 32 位逐次右移到低 32 位。每次迭代，向 32 位商寄存器的最低位添加 0 或 1。

> 注意，改进前的除法器一共进行 33 次（n + 1次）迭代。

![image-20250106195331881](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106195331881.png)

### 改进的除法器：分步列出寄存器的值

同样，上述除法器效率低、寄存器空间浪费大。通过扩充控制逻辑，除法可以在改进的乘法器硬件中完成。

注意到每轮迭代，余数（一开始是被除数）位数从 64 减少到 32，商的位数从 0 增加到 32，合起来总是 64 位，可以拼接成一个 64 位余数/商寄存器，最后的余数即为整个除法的余数。

ALU 只对高 32 位进行减法。

> 和改进前不同，只进行 32 次（n次）迭代。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106202349981.png" alt="image-20250106202349981" style="zoom:80%;" />

| 迭代 |         步骤         | 除数 |   余/商   |
| :--: | :------------------: | :--: | :-------: |
|  0   |       initial        | 0010 | 00000111/ |
|  1   |       余 << 1        | 0010 | 0000111/0 |
|      |     余 = 余 - 除     | 0010 | 1110111/0 |
|      | 余 = 余 + 除，商置 0 | 0010 | 0000111/0 |
|  2   |       余 << 1        | 0010 | 000111/00 |
|      |     余 = 余 - 除     | 0010 | 111111/00 |
|      | 余 = 余 + 除，商置 0 | 0010 | 000111/00 |
|  3   |       余 << 1        | 0010 | 00111/000 |
|      |     余 = 余 - 除     | 0010 | 00011/000 |
|      |        商置 1        | 0010 | 00011/001 |
|  4   |       余 << 1        | 0010 | 0011/0010 |
|      |     余 = 余 - 除     | 0010 | 0001/0010 |
|      |        商置 1        | 0010 | 0001/0011 |

### 乘除法的进一步改进、MIPS 乘除运算指令

> 乘法和除法都通过记忆符号、将操作数转化为自然数、再进行运算，最后对负数结果取反。

为了进一步加快乘法运算，可以采用 31 个 ALU 拼接成**并行树乘法器**。

**SRT 除法算法**通过查表来预测每步有几个商位，每步生成多个商位。

超前进位加法器、并行树、SRT，都借助摩尔定律提供的丰富硬件资源加大电路规模来加速，属于**用空间换时间**的加速策略。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106203953642.png" alt="image-20250106203953642" style="zoom:80%;" />

MIPS 提供 **`mult`**、**`multu`**、**`div`**、**`divu`**。

四条乘除运算指令，均为**双操作数** R 型指令。

对乘法，`Hi, Lo = reg1 x reg2`;

对除法，`Hi =reg1 % reg2`，`Lo = reg1 / reg2`；

从 `Hi` 中获得 **`mfhi`**、从 `Lo` 中获得 **`mflo`**，均为单操作数 R 型指令。

## 复习（一）

1. 补码加减的溢出分为哪两种，分别对应哪四个情况？<u>上溢（正 + 正 or 正 - 负），下溢（负 + 负 or 负 - 正）。</u>
2. 为什么最低位 ALU 不接收进位，也要使用全加器？
3. 为了支持 `and`、`or` 运算，采用哪种数字电路部件来选择信号？`nor` 运算怎么实现？
4. 32 位 ALU 怎样支持 `slt` 和条件分支指令？
5. 三组（四位）ALU 控制信号的作用分别是什么？
6. 行波进位和超前进位加法器的门延迟分别怎么计算？<u>对于行波进位，每一位经过一个与门和一个或门，因此 32 位门延迟为 64；对于超前进位，32 位为 4 的 2.5 次方，将 2.5 向上取整后加一，得到的 4 就是超前进位加法器的门延迟。</u>
7. 改进前的乘法器，控制逻辑实现哪些功能？
   - 根据乘数最低位是否为 1 来判断被乘数是否加到积上；
   - 将被乘数左移，将乘数右移；
   - 计数。
8. 改进后的乘法器和除法器是否可以共用一套硬件？64 位寄存器怎么变化？<u>可以；对于乘法寄存器，进行右移操作；对于除法寄存器，进行左移操作。</u>
9. （SCU）熟练掌握分步列出**改进后**的乘除法器中寄存器的值
10. 乘法、除法分别用什么策略实现进一步改进？<u>并行树，SRT 算法。</u>

## 浮点数的表示与运算

### 浮点数规格化、IEEE 754 单精度浮点数

为了表示非整数实数，现在的计算机广泛采用小数点浮动的**浮点数（float point number)**。

以十进制小数 -0.75 为例：

1. 转化为二进制实数 (小数)；

2. 将二进制实数表示为以 2 为基数的科学记数法，这个过程称为规格化。

此时得到三个信息：

- 实数的正负；
- 小数点右边的尾数；
- 2 的指数。

> 规格化的二进制小数，只要不是 0.0，且没有超出表示范围，**小数点左边一定是 1**。

IEEE 754 规定，**单精度浮点数**大小为 32 位，其中最高 1 位是**符号位（sign）**，随后 8 位是**指数域（exponent)**，剩下的位全部用来表示**尾数（fraction）**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106212017609.png" alt="image-20250106212017609" style="zoom:80%;" />

### 浮点表示范围

8 位指数可以表示从 0～255 共 256 个自然数，但是只有 1～254 表示真正的浮点数（0 和 255 表示特殊的含义）。

为了便于比较大小，浮点数的指数域采用一种类似于**移码**（大小变化与无符号数相同，所以方便直接比较大小）的表示方法：

**-126～+127** 的真正指数分别映射到 1（00000001）～254（11111110)。

也就是说，计算出真正的指数（阶数）之后，还要加上 127 的**偏阶**。

> 为什么是 127？
>
> 使得指数的正负范围对称，便于硬件实现比较和排序操作。类似的，对于 11 位指数位的双精度浮点数，有 $2^{10} - 1$，也即是 1023 的偏阶数。

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Table Representation</title>
    <style>
        table {
            border-collapse: collapse;
            width: 100%;
            text-align: center;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <table>
        <thead>
            <tr>
                <th colspan="2">单精度</th>
                <th colspan="2">双精度</th>
                <th rowspan="2">表示的数</th>
            </tr>
            <tr>
                <th>指数</th>
                <th>尾数</th>
                <th>指数</th>
                <th>尾数</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>0</td>
                <td>000</td>
                <td>0</td>
                <td>000</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0</td>
                <td>非零</td>
                <td>0</td>
                <td>非零</td>
                <td>±非规格化数</td>
            </tr>
            <tr>
                <td>1～254</td>
                <td>任意</td>
                <td>1～2046</td>
                <td>任意</td>
                <td>±规格数</td>
            </tr>
            <tr>
                <td>255</td>
                <td>0</td>
                <td>2047</td>
                <td>0</td>
                <td>±无穷</td>
            </tr>
            <tr>
                <td>255</td>
                <td>非零</td>
                <td>2047</td>
                <td>非零</td>
                <td>NaN（非数）</td>
            </tr>
        </tbody>
    </table>
</body>
</html>


因此，单精度浮点数的表示范围（绝对值）是：

$$
\begin{align*}
&\pm 1.0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000_2 \times2^{−126} \\
&\pm 1.1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111_2  \times 2^{127}
\end{align*}
$$

### IEEE 754 双精度浮点数

为了表示范围更大、精度更高的浮点数，IEEE 754 提供了**双精度浮点数**标准，共 64 位。其中最高 1 位是**符号位**，随后 11 位是**指数域**，剩下的位全部用来表示**尾数**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106224916388.png" alt="image-20250106224916388" style="zoom:80%;" />

此时**偏阶**相应变为 1023。

---

将 IEEE 754 单精度浮点数 `1100 0000 1010 0000......` 转换为十进制真值为 -5。

IEEE 754 标准后来扩充了 16 位半精度、128 位四精度浮点数标准。

### 浮点加法运算的步骤

以 $0.5 - 0.4375$ 为例，转换为二进制科学计数法：$1.0 \times 2^{-1} - 1.11 \times 2^{-2}$。

1. **小对大**：指数较小的数化为较大指数的形式，$1.0 \times 2^{-1} - 0.111 \times 2^{-1}$；
2. **再相加**：列竖式相加，$0.001 \times 2^{-1}$；
3. **规格化**：将和重新规格化，$1.0 \times 2^{-4}$；
4. **舍入查**：四舍五入，检查是否发生指数**溢出**；对单精度，指数高于 +127 称为**上溢**，低于 -126 称为**下溢**。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250106230126234.png" alt="image-20250106230126234" style="zoom:50%;" />

> 如果直接调整较大的数的指数来对齐较小的数（即 “大对小”），可能会丢失较大的数中的重要高位信息，导致结果严重失真。

### 浮点乘法运算步骤

以 $0.5 \times (-0.4375)$ 为例，先不考虑正负号：$1.0 \times 2^{-1} \times (- 1.11 \times 2^{-2})$。

1. **指数加**：被乘数和乘数的指数相加，$-1 + (-2) = -3$。

   > 注意，是真正指数（而不是加了偏阶的指数）相加。

2. **再相乘**：列竖式相乘，$1.11 \times 2^{-3}$；

3. **规格化**：将积重新规格化；

4. **舍入查**：四舍五入，检查是否发生指数溢出；

### MIPS 浮点运算指令算术运算精度

为了专门存放浮点数，MIPS 体系结构增加了单独的 32 个**单精度浮点寄存器** `$f0`～`$f31`。一对单精度寄存器组合成一个**双精度寄存器**，以偶数编号。

`add`、`sub`、`mul`（不是`mult`）`div` 打点加 `s` 表示单精度，`d` 表示双精度，构成**浮点运算指令**。

**浮点比较指令**有单精度 `c.x.s` 和双精度 `c.x.d` 两组，`x` 可以取六种比较条件中的一个（`eq`、`neq`、`lt`、`le`、`gt`、`ge`）。当比较条件为真时，将**浮点比较结果**置为 1，否则置为 0；随后，使用**浮点比较为真跳转 `bclt`** 或**浮点比较为假跳转 `bclf`** 指令进行条件分支。

浮点数不能表示所有实数，通常只是一个近似值，舍入时需要硬件保留更多有效位。IEEE 754 右边总是多保留两个额外的尾数位用于舍入，分别叫做**保护位**和**舍入位**。在正常情况下，**尾数最低位（unit in the last place，ulp）**误差数目不超过 0.5。即，误差都在半个 ulp 以内。

> 我们常用 `sll` 实现乘二的幂，但是用 `slr` 来实现除以二的幂会出现问题。

## 复习（二）

1. IEEE 754 浮点数分为哪三段？分别代表什么含义？<u>符号位、指数域、尾数域。</u>

2. 三个字段在单双精度中各有多长？由此得出，单双精度的偏阶分别为多少？

   <u>单精度：1，8，23，127；双精度：1，11，52，1023</u>。

3. 单双精度表示真正浮点数的范围分别是多少？

   $$
   \begin{align*}
   &\pm 1.0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000_2 \times2^{−126} \\
   &\pm 1.1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111_2  \times 2^{127}
   \end{align*}
   $$

4. IEEE 754 浮点数和十进制真值的转化要登峰造极、熟稔于心；

5. 浮点加法有哪四个步骤？浮点乘法有哪五个步骤？

6. IEEE 754 保留的额外两个尾数位分别叫什么？其运算误差不超过多少个 ulp？<u>保护位、舍入位；不超过 0.5 个 ulp。</u>

## 习题

### 教材习题

1. 计算十六进制符号-数值表示的减法 5ED4 - 07A4：

   <img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250107152023250.png" alt="image-20250107152023250" style="zoom:67%;" />

2. 写出十进制数 63.25 的 IEEE 754 双精度表达：

   ![image-20250107152604966](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250107152604966.png)

3. 写出实数 $\frac{1}{3}$ 的二进制形式，不需要规格化。这个数能否被 IEEE 754 浮点数精确表达？

   不可以，因为是无限循环小数，后面的循环部分被阶段掉。

   ![image-20250107152730856](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250107152730856.png)

### 川大真题

![image-20250107153735610](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250107153735610.png)

![image-20250107154632140](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250107154632140.png)

存在一种“半精度”格式，只有 16 位宽，最高位是数符，指数是 5 位宽且偏阶为 15 的移码表达，尾数有 10 位宽，具有隐含 1。写出 10 进制 -9.625 的半精度二进制位表达式：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/image-20250107155030594.png" alt="image-20250107155030594" style="zoom:50%;" />

使用改进后的乘法器硬件计算 $-13_{10} \times 9_{10}$，其中两个数都用 5 位二进制补码表示。(要求写出每一步各寄存器中的值）。

| 迭代 |         步骤         | 被乘数 |   积/乘数   |
| :--: | :------------------: | :----: | :---------: |
|  0   |       initial        | 01101  | 00000/01001 |
|  1   | 1 → 积 = 积 + 被乘数 | 01101  | 01101/01001 |
|      |         右移         | 01101  | 001101/0100 |
|  2   |     0 → 积 = 积      | 01101  | 001101/0100 |
|      |         右移         | 01101  | 0001101/010 |
|  3   |     0 → 积 = 积      | 01101  | 0001101/010 |
|      |         右移         | 01101  | 00001101/01 |
|  4   | 1 → 积 = 积 + 被乘数 | 01101  | 01110101/01 |
|      |         右移         | 01101  | 001110101/0 |
|  5   |     0 → 积 = 积      | 01101  | 001110101/0 |
|      |         右移         | 01101  | 0001110101/ |

转换为补码，有 `1110001011`。

使用改进的除法器计算无符号除法 $\dfrac{9_{10}}{3_{10}}$，其中两源操作数均为 4 位。要求写出执行每个步骤后寄存器中的值：

| 迭代 |         步骤         | 除数 |   余/商   |
| :--: | :------------------: | :--: | :-------: |
|  0   |       initial        | 0011 | 00001001/ |
|  1   |       余 << 1        | 0011 | 0001001/0 |
|      |     余 = 余 - 除     | 0011 | 1110001/0 |
|      | 余 = 余 + 除，商置 0 | 0011 | 0001001/0 |
|  2   |       余 << 1        | 0011 | 001001/00 |
|      |     余 = 余 - 除     | 0011 | 111101/00 |
|      | 余 = 余 + 除，商置 0 | 0011 | 001001/00 |
|  3   |       余 << 1        | 0011 | 01001/000 |
|      |     余 = 余 - 除     | 0011 | 00011/000 |
|      |        商置 1        | 0011 | 00011/001 |
|  4   |       余 << 1        | 0011 | 0011/0010 |
|      |     余 = 余 - 除     | 0011 | 0000/0010 |
|      |        商置 1        | 0011 | 0000/0011 |
