# 1.数组元素的数量
```c
int main(void)
{
	int arr[] = { 31,22,23,87,5,6,7,100,31 };
	int sz = sizeof(arr) / sizeof(arr[0]);
    
	printf("%d", sz);
    
	return 0;
}
```
上述代码通过关键字`sizeof`来计算数组的大小和数组内一个元素的大小，最后两者相除，得到数组内元素的数量。

注意，用此方法计算字符数组的元素个数时，会同时计算末尾的'\0'，导致偏多。（计算字符数组最好用`strlen()`函数）<img src="https://cdn.nlark.com/yuque/0/2023/png/38980263/1697882733878-0058711a-5799-4948-a3e4-eb3749880215.png#averageHue=%23b8d8bc&clientId=u3933ec1b-e98c-4&from=paste&height=191&id=u3bbf9cd8&originHeight=239&originWidth=747&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=186159&status=done&style=none&taskId=ud6afc039-a26d-494f-b061-7c666b5a8b7&title=&width=597.6" alt="image.png" style="zoom:80%;" />

在二维数组中，将每一行的**一维数组**当成**一个元素**，它的数组名代表第一行的地址，也就是所谓首元素的地址。

```c
printf("%d\n", sizeof(arr) / sizeof(arr[0])); // arr[0]代表第一行数据
printf("%d\n", sizeof(arr[0]) / sizeof(arr[0][0]));
```

第一行代码可以算出数组有几行，第二行代码可以算出数组有几列。（通过算一行元素中有几个）

# 2.数组名
```
arr[1] == *(arr + 1);
```

`[]`代表一个操作符，如上图。

所加的1代表移动1个该数据类型大小的地址。如**int**类型的数组，就在地址上加上4个或8个字节。

数组名能代表第一个元素的地址。

数组名存储着地址，数组名指向的地址是它第一个元素的地址。因此不用像变量那样进行**取地址的操作**（即&）。因此在传给函数时，实际上是传址操作，传的是第一个元素的地址。

**但是有两个例外：**

- <img src="https://cdn.nlark.com/yuque/0/2023/png/38980263/1697359426904-33478333-eb13-4897-9b8c-53842903e52e.png#averageHue=%239bc49f&clientId=u92e58f88-0ad2-4&from=paste&height=22&id=u83b08acd&originHeight=28&originWidth=871&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=60169&status=done&style=none&taskId=ue6f11325-df6e-4183-9ec4-c63ecf6dd84&title=&width=696.8" alt="image.png" style="zoom:80%;" />

- <img src="https://cdn.nlark.com/yuque/0/2023/png/38980263/1697359457994-3f6dd9e6-66a3-4f2b-94d9-f77751fc5e36.png#averageHue=%2393c098&clientId=u92e58f88-0ad2-4&from=paste&height=22&id=uefcf2069&originHeight=27&originWidth=658&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=45962&status=done&style=none&taskId=u1b4512e4-104b-494e-a476-aba2cb9efcd&title=&width=526.4" alt="image.png" style="zoom:80%;" />

  如：`printf("%p\n", &arr);`在执行`printf("%p\n", &arr+1)`时，与`printf("%p\n", &arr[0]+1)`不同，前者的地址是首元素的地址再加上整个数组，后者的地址是下一个元素的地址。

# 3.一维数组的创建和初始化
## （1）数组的创建
在C99标准之前，数组的大小必须是常量或者常量表达式；

在C99标准之后，数组的大小可以是变量，为了支持变长数组。在支持C99标准的编译器上可以运行，而VS不支持，而`gcc`支持。同时，变长数组不支持初始化。

## （2）数组的初始化
```C
int main(void)
{
	int arr[10] = {1,2,3};
	
	return 0;
}
```

需要注意的是，在上述数组中，除了前三个元素被初始化，其他都默认为0；除了`int arr[10] = {0}`之外，不能出现`int arr[10] = {1}`的情况，它只有第一个元素被初始化为1，其他的都是0。

# 4.二维数组的创建和初始化

## （1）数组的创建
```
// 数组创建
int arr[3][4];
char arr[3][5];
double arr
```

前面那个括号代表有几行，后面那个括号代表有几列。

## （2）数组的初始化
```c
int arr1[3][4] = {1,2,3,4,2,3,4,5,3,4,5,6};
```

根据数据直接进行初始化，将元素反在数组中，不足的补零。

```C
int arr1[3][4] = {{1, 2}, {3, 4}, {5, 6}};
```

通过括号里面括号的方式，将{1,2}放在第一行，将{3,4}放在第二行，将{5,6}放在第三行。可以进行分组。

``` C
int arr[][4] = {{2,3}, {4,5}}; // 二维数组如果有初始化，行可以省略，列不能省略
```

访问数组元素的方式与一维数组类似。

# 5.数组作为函数参数
冒泡排序:

<img src="https://cdn.nlark.com/yuque/0/2023/png/38980263/1697354210928-51bf8235-bf31-44ee-ad74-54b3a8d3bcbe.png#averageHue=%23f8f0e9&clientId=u05ea89ba-281a-4&from=paste&height=342&id=u15ca851e&originHeight=427&originWidth=527&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=101346&status=done&style=none&taskId=u600e3b9c-09cb-4f13-9516-1338e095895&title=&width=421.6" alt="image.png" style="zoom:80%;" />

一次n个元素的冒泡排序会将最大的元素放在最后，然后在做n-1个元素的冒泡排序。

完成9次冒泡排序会让9个元素到正确的位置，最后一个元素自然会在正确的位置。

```c
// 数组传参有两种写法
// 第一种是数组的方法:int arr[]                     
// 第二种是指针的方法:int* str

#include <stdio.h>

void bubble_sort(int arr[], int sz) // sz要在函数外部求
{                                   // 传参时只传了第一个元素地址
    int i = 0;
    
    for (i = 0; i < sz - 1; i++) // 表示进行sz-1次排序
    {
        int j = 0;

        for (j = 0; j < sz - 1 - i; j++) // 进行sz-1-i个元素的排序
        {                                // 每排序一次，i++
            if (arr[j] > arr[j + 1])     // 需要排序的元素个数减少
            {
                int tmp = arr[j + 1]; // 将两个相邻的数进行交换

                arr[j + 1] = arr[j]; // 经过循环后，该次循环最大的数就会位于该次循环元素的最后
                arr[j] = tmp;
            }
        }
    }
}
```
# 6.数组的数据类型
以`int arr[10] = {0}`为例，它的类型就是`int [10]`。
```c
sizeof(arr);
sizeof(int[10]);
```
通过计算，两者的大小是一致的。
# 7.变长数组

在**gcc**中，有：

```c
#include <stdio.h>

int main(void)
{
    int n = 0;
    int i = 0;
    int arr[n]; // 变长数组不能初始化

    scanf("%d", &n);
    for (i = 0; i < n; i++)
    {
        scanf("%d ", arr[i]);
    }
    for (i = 0; i < n; i++)
    {
        printf("%d ", arr[i]);
    } // 常规的输入输出

    return 0;
}
```

# 8.指针的定义

内存被切割成一个个内存单元，一个内存单元是1byte（1个字节）。

> 1. 指针是内存中一个最小单元的编号，也就是地址。
> 2. 平时说的指针通常指的是指针变量，是用来存放内存地址的变量。

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231031141343752.png" alt="image-20231031141343752" style="zoom:80%;" />

在取地址的时候，是取变量的第一个地址。如`&a`，如果`a`是整形，则取地址时取的是**第一个内存单元**的地址。

指针变量中存放的是地址，通过地址可以找到一个内存单元。

对32位的机器，有32条地址线，每根地址线在寻址的时候会产生高电平和低电平：

```
00000000 00000000 00000000 00000000
```

而上面的组合有$2^{32}$种，有$2^{32}$个地址。64位机器同理。

在32位机器上，因为有32位数，所以要4个字节来存储。

额外：

```c
int* a = NULL;
*a = 50; // 这句代码是错的，因为这个地址不能访问，C语言中存在一些不能访问的地址。
```

# 9.指针和指针类型

```c
#include <stdio.h>

int main(void)
{
    int a = 0x11223344;
    char* pc = (char*)&a;

    *pc = 0;

    return 0;
}
```

对于上述代码，因为只访问了一个内存单元，所以只改变了一个内存单元的值，如下图：

![](C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231031151453905.png)

变为：

![image-20231031151347575](C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231031151347575.png)

因此，**指针类型决定了解引用时访问内存单元的个数**，如字符类型只访问1个字节，而整形访问4个字节。

```c
#include <stdio.h>

int main(void)
{
    int a = 0x11223344;
    int *pa = &a;
    char *pc = (char *)&a;

    printf("%p\n", pa);
    printf("%p\n", pa + 1);
    printf("%p\n", pc);
    printf("%p\n", pc + 1);

    return 0;
}
```

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231031152243328.png" alt="image-20231031152243328" style="zoom:80%;" />

由上述代码可知，**指针的类型决定了指针+1或-1时（例子是1，可以是整数），跳过字节的个数**，如`int`类型是跳过4个字节，`char`类型是跳过1个字节。

```c
#include <stdio.h>

int main(void)
{
    int a = 0;
    int *pi = &a;
    float *pf = &a;

    *pi = 100; // *pf = 100.0;

    return 0;
}
```

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231103123022623.png" alt="image-20231103123022623" style="zoom:80%;" />

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231103123247289.png" alt="image-20231103123247289" style="zoom:80%;" />

虽然`float`、`int`类型都有跳过4个字节等特性，但由于类型不用，所以解引用时访问内存的方式不同，所以不能混用。

如上述代码，因为指针类型不同，存储类型的方式不同。

# 10.野指针

一个局部的指针变量没有初始化，就会随机指向一个地址，而后解引用，此时就是非法访问内存，这就是野指针，如果不知道赋何值，可以赋值`int *p = NULL`，这是空指针。

```c
int* p;
*p = 10;
```

这是一种情况，还有一种是指针越界访问：

```c
#include <stdio.h>

int main(void)
{
    int arr[10] = {0};
    int *p = arr; // &arr[0]
    int i = 0;

    for (i = 0; i <= 10; i++)
    {
        *p = i; // i = 10时，就会越界访问，造成野指针
        p++;
    }

    return 0;
}
```

还有：

```c 
#include <stdio.h>

int *test(void)
{
    int a = 0;

    return &a;
}

int main(void)
{
    int *p = test();

    return 0;
}
```

在上述代码中，因为a是局部变量，运行完函数就销毁了。然而在p中存有a的地址，但a的内存已经归还了，此时它也是野指针。这时候就是赋值空指针也没有用。

举例：

```c
#include <stdio.h>

int* test(void)
{
	int a = 10;

	return &a;
}

int main(void)
{
	int* p = test();

	if (p != NULL)
		printf("%d\n", *p);

	return 0;
}
```

在VS中，会输出：

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231101210819058.png" alt="image-20231101210819058" style="zoom:80%;" />

由此可知，此时`p != NULL`这句代码不能实现，并且虽然变量a已经销毁，但在那个地址的值还没有被其他值覆盖，所以解引用的时候依旧会输出10。

而：

```c
#include <stdio.h>

int* test(void)
{
	int a = 10;

	return &a;
}

int main(void)
{
	int* p = test();
	printf("hada\n");

	if (p != NULL)
		printf("%d\n", *p);

	return 0;
}
```

输出：

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231101211319112.png" alt="image-20231101211319112" style="zoom:80%;" />

这是因为调用函数时会创建自己的函数栈帧，原来的被覆盖了。

规避野指针方法集锦：

1. 指针初始化
2. 小心指针越界
3. 指针指向的空间释放，即使初始化为NULL
4. 避免返回局部变量的地址
5. 指针使用之前检查有效性

# 11.指针运算

- 指针+-整数
- 指针-指针
- 指针的关系运算

下面的代码反映了指针的关系运算：

```c
#define N_VALUES 5

int main(void)
{
    float *vp;
    float values[N_VALUES];

    for (vp = &values[0]; vp < &values[N_VALUES];) // 两个指针进行比较，这就是关系运算，因为地址由低到高
    {
        *vp++ = 0; // -> *vp = 0; vp++;与(*vp)++不同
    }

    return 0;
}
```

因此，遍历数组可以写成：

```c
#include <stdio.h>

int main(void)
{
    int arr[10] = {0};
    int *p = arr;
    int i = 0;

    for (i = 0; i < 10; i++)
    {
        *(p + i) = 1;
    }

    return 0;
}
```

而在指针-指针中，有：

```C
#include <stdio.h>

int main(void)
{
    int arr[10] = {0};

    printf("%d\n", &arr[9] - &arr[0]);

    return 0;
}
```

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231103123931217.png" alt="image-20231103123931217" style="zoom:80%;" />

因为指针-指针得到的这个数值的绝对值是两个指针中元素的个数。（前提条件：不是所有的指针都能相减，指向同一块内存空间的两个指针才能相减！）

错误示范：

```c
#include <stdio.h>

int main(void)
{
    int arr[10] = {0};
    char ch[5] = {0};

    printf("%d\n", &ch[0] - &arr[0]); // 没有意义的东西

    return 0;
}
```

值得注意的是，指针+指针没有意义。

关系运算：

```c
for (vp = &value[N_VALUES]; vp > &value[0];)
{
    *--vp = 0; // 先解引用给*vp赋值0，然后再给vp--；虽然它向后越界访问了p2，但是标准支持
}
```

```C
for (vp = &value[N_VALUES - 1]; vp >= &value[0]; vp--)
{
    *vp = 0; // 这个向前越界访问了p1，标准不支持
}
```

虽然上面的代码看起来比下面的代码要更好，但是由于**标准规定**：

> 允许指向数组元素的指针与指向数组最后一个元素后面的哪一个内存位置的指针比较，但是不允许指向第一个元素之前的那个内存位置的指针进行比较。

从上面那个代码来看，下面那个代码在最后一次循环中地址`vp`与`&value[0]`进行比较，违反了规定。（虽然在大部分编译器下可以运行）但如果是正着初始化，就不会有问题。

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231103134402819.png" alt="image-20231103134402819" style="zoom: 67%;" />

# 12.二级指针

```c
#include <stdio.h>

int main(void)
{
    int a = 0;
    int *pa = &a;
    int **ppa = &pa; // 二级指针表示方式

    **ppa = 20; // 二级指针解引用方法
    printf("%d\n", a);

    return 0;
}
```

大体上关系如图：

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231103145450691.png" alt="image-20231103145450691" style="zoom: 67%;" />

二级指针变量是用来存储一级指针变量的地址的变量。

# 13.指针数组

指针数组：存放指针的数组就是指针数组。

```c
#include <stdio.h>

int main(void)
{
    int a = 10, b = 20, c = 30;
    int arr[10];
    // int *pa = &a, *pb = &b, *pc = &c; // 这种写法是一个个写。
    int *parr[10] = {&a, &b, &c}; // 写成数组，此时parr就是指针数组。

    return 0;
}
```

适当修改后：

```c
#include <stdio.h>

int main(void)
{
    int a = 10, b = 20, c = 30, i = 0;
    int *parr[10] = {&a, &b, &c};

    for (i = 0; i < 3; i++)
    {
        printf("%d\n", *(parr[i])); // 此时就和直接遍历数组进行打印效果类似
    }

    return 0;
}
```

指针数组可以模拟二维数组。

直接写法：

```C
#include <stdio.h>

int main(void)
{
    int i = 0, j = 0;
    int arr[3][4] = {1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6};

    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 4; j++)
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

模拟写法：

```c
#include <stdio.h>

int main(void)
{
    int i = 0, j = 0;
    int arr1[4] = {1, 2, 3, 4};
    int arr2[4] = {2, 3, 4, 5};
    int arr3[4] = {3, 4, 5, 6};
    int *parr[3] = {&arr1, &arr2, &arr3};

    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 4; j++)
        {
            printf("%d ", parr[i][j]); // 调用两次下标引用操作符，第一次是找到相应的数组，第二次是找到相应数组的相应元素
        }
        printf("\n");
    }

    return 0;
}
```

均可打印出：

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231103152615104.png" alt="image-20231103152615104" style="zoom:80%;" />