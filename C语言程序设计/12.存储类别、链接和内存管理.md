# 1.栈区、堆区和静态区
<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2F329271b5dc2f4d0c541e38208e758c61--17f0--1697288479246-506b60d5-f39f-48aa-9047-a0841c5796d4.png" alt="image.png" style="zoom: 80%;" />

在静态区中，静态变量和全局变量默认被初始化为0，而在栈区中，默认被初始化为随机值。

举一个在栈区中的例子：

```c
#include <stdio.h>

int main(void)
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hello world\n");
	}

	return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Ff69aabcbc5b1a4928df466314a666e99--30bb--image-20231107125616940.png" alt="image-20231107125616940" style="zoom:80%;" />

在这个越界访问的例子中，可以看到`i`的值与`arr[12]`的值相等，两个变量所占据的空间相同。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Fd120f58010334f3420f17be79ccdef60--5dfd--image-20231107130616147.png" alt="image-20231107130616147" style="zoom:67%;" />

1. 栈区内存的使用习惯是先使用高地址处的空间，再使用低地址处的空间。
2. 数组随着下标的增长，地址是由低到高变化的。
3. 如果`i`和`arr`之间由适当的空间，利用数组的越界操作就可能会覆盖到，就可能会导致死循环的出现。

另外：

数字在内存中是倒着存的，如$0x11223344$，它在内存在由低地址存向高地址（这体现了从低到高存）：

```
   44 33 22 11
// 低        高
```

（注意：在Release版本里面，内存开辟的方式与Debug的不同，`i`在低地址，而`arr`在高地址，所谓的优化）

# 2.类型的基本归类

- 整形家族：

```c
char
	unsigned char
	signed char
short
	unsigned short [int]
	signed short [int]
int 
	unsigned int
	signed int
long
	unsigned long [int]
	signed long [int]
long long
  unsigned long long [int]
  signed long long [int]
```

（注意：`char`被当作`unsigned char`或者`signed char`取决于编译器的类型，而其他的类型都是`signed`，其他的要加`unsigned`）。

- 浮点型家族

```c
float
double
```

- 构造类型

```c
> 数据类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
```

举例：

```c
int arr1[5] = {0}; // 类型为int [5]
int arr2[8] = {0}; // 类型为int [8]
char arr3[5] = {0}; // 类型为char [5]
```

- 指针类型

```c
int *pi
char *pc
float *pf
void *pv
```

- 空类型

```c
void // 表示为空类型
```

通常应用于函数的返回类型、函数的参数、指针类型。

# 3.原码、反码、补码

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值位统一处理；

同时，加法和减法也可以统一处理（**CPU只有加法器**）。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

`char`类型能存的数据大小$[-127,128]$，而`unsigned char`的取值范围是$[0,255]$。

- 例1：

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char a[1000];
    int i;

    for (i = 0; i < 1000; i++)
    {
        a[i] = -1 - i;
    }
    printf("%d\n", strlen(a));

    return 0;
}
```

可知字符串靠`\0`来截止，那就看$[-128,127]$，一开始是$-1$，通过减一后面变成$-128$（10000000）时，再减一就变成了$127$（01111111）；而后再进行$-1$运算，直到$0$。

- 例2：

```c
#include <stdio.h>

int main(void)
{
    if (strlen("abc") - strlen("abcdef") > 0)
        printf(">\n");
    else
        printf("<\n");

    return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Fc7c17442812b2f191926a93f829ec512--f9ea--image-20231119115342838.png" alt="image-20231119115342838" style="zoom: 80%;" />

因为`strlen()`的返回类型为`size_t`即`unsigned int`，所以进行的是无符号整形的计算，因此返回的也是无符号整形。

# 4.大小端介绍

什么是大小端？

> 大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
>
> 小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。

举例：存储一个数$0x11223344$。

判断大小端：

```c
#include <stdio.h>

int main(void)
{
    int a = 1;

    if (*(char *)&a == 1)
        printf("小端\n");
    else
        printf("大端\n");

    return 0;
}
```

升级版：

```c
int check_sys(void)
{
    int a = 1;

    return *(char *)&a; // 返回第一个字节，如果是1，就返回1；是0，就返回0
}
```

因为指针所指向的是从低地址指向高地址的第一个字节的地址，所以当指向4个字节的整形指针被截断为指向第一个字节的字符指针，该指针所指向的就是存在内存中的第一个字节的地址，也就是一个字节的内容。此时如果是小端字节序，低位存在低地址，就会显示`1`，而如果是大端字节序，高位存储在低地址，就会显示`0`。

# 5.浮点数存储

M可以写成$1.xxxxxx$的形式，其中$xxxxxx$表示小数部分。 IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的$xxxxxx$部分。比如保存$1.01$的时 候，只保存$01$，等到读取的时候，再把第一位的$1$加上去。这样做的目的，是节省$1$位有效数字。以$32$位浮点数为例，留给M只有$23$位，将第一位的$1$舍去以后，等于可以保存$24$位有效数字。

E不全为0或不全为1：

> 这时，浮点数就采用下面的规则表示，即指数E的计算值减去$127$（或$1023$），得到真实值，再将 有效数字M前加上第一位的1。 比如： $0.5（1/2）$的二进制形式为$0.1$，由于规定正数部分必须为1，即将小数点右移1位，则为$1.0*2^{-1}$，其阶码为-1+127=126，表示为 $01111110$，而尾数$1.0$去掉整数部分为$0$，补齐$0$到$23$位$00000000000000000000000$，则其二进制表示形式为:

```
0 01111110 00000000000000000000000
```

E全为0：

> 这时，浮点数的指数E等于$1-127$（或者$1-1023$）即为真实值， 有效数字M不再加上第一位的$1$，而是还原为$0.xxxxxx$的小数。这样做是为了表示$±0$，以及接近于$ 0$的很小的数字。

E全为1：

> 这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）。

