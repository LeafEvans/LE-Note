# 1.栈区、堆区和静态区
<img src="https://cdn.nlark.com/yuque/0/2023/png/38980263/1697288479246-506b60d5-f39f-48aa-9047-a0841c5796d4.png#averageHue=%23efdbd4&clientId=u4c20501c-22c3-4&from=paste&height=454&id=ud3ac0394&originHeight=567&originWidth=327&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=79211&status=done&style=none&taskId=ue766ccd3-3059-4800-9aad-8850fe6f630&title=&width=261.6" alt="image.png" style="zoom: 80%;" />

在静态区中，静态变量和全局变量默认被初始化为0，而在栈区中，默认被初始化为随机值。

举一个在栈区中的例子：

```c
#include <stdio.h>

int main(void)
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hello world\n");
	}

	return 0;
}
```

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231107125616940.png" alt="image-20231107125616940" style="zoom:80%;" />

在这个越界访问的例子中，可以看到`i`的值与`arr[12]`的值相等，两个变量所占据的空间相同。

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231107130616147.png" alt="image-20231107130616147" style="zoom:67%;" />

1. 栈区内存的使用习惯是先使用高地址处的空间，再使用低地址处的空间。
2. 数组随着下标的增长，地址是由低到高变化的。
3. 如果`i`和`arr`之间由适当的空间，利用数组的越界操作就可能会覆盖到，就可能会导致死循环的出现。

另外：

数字在内存中是倒着存的，如$0x11223344$，它在内存在由低地址存向高地址（这体现了从低到高存）：

```
   44 33 22 11
// 低        高
```

（注意：在Release版本里面，内存开辟的方式与Debug的不同，`i`在低地址，而`arr`在高地址）

# 2.类型的基本归类

- 整形家族：

```c
char
	unsigned char
	signed char
short
	unsigned short [int]
	signed short [int]
int 
	unsigned int
	signed int
long
	unsigned long [int]
	signed long [int]
long long
  unsigned long long [int]
  signed long long [int]
```

（注意：`char`被当作`unsigned char`或者`signed char`取决于编译器的类型，而其他的类型都是`signed`，其他的要加`unsigned`）。

- 浮点型家族

```c
float
double
```

- 构造类型

```c
> 数据类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
```

举例：

```c
int arr1[5] = {0}; // 类型为int [5]
int arr2[8] = {0}; // 类型为int [8]
char arr3[5] = {0}; // 类型为char [5]
```

- 指针类型

```c
int *pi
char *pc
float *pf
void *pv
```

- 空类型

```c
void // 表示为空类型
```

通常应用于函数的返回类型、函数的参数、指针类型。

# 3.原码、反码、补码

在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值位统一处理；

同时，加法和减法也可以统一处理（**CPU只有加法器**）。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

`char`类型能存的数据大小$[-127,128]$，而`unsigned char`的取值范围是$[0,255]$。

- 例1：

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char a[1000];
    int i;

    for (i = 0; i < 1000; i++)
    {
        a[i] = -1 - i;
    }
    printf("%d\n", strlen(a));

    return 0;
}
```

可知字符串靠`\0`来截止，那就看$[-128,127]$，一开始是$-1$，通过减一后面变成$-128$（10000000）时，再减一就变成了$127$（01111111）；而后再进行$-1$运算，直到$0$。

- 例2：

```c
#include <stdio.h>

int main(void)
{
    if (strlen("abc") - strlen("abcdef") > 0)
        printf(">\n");
    else
        printf("<\n");

    return 0;
}
```

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231119115342838.png" alt="image-20231119115342838" style="zoom: 80%;" />

因为`strlen()`的返回类型为`size_t`即`unsigned int`，所以进行的是无符号整形的计算，因此返回的也是无符号整形。

# 4.大小端介绍

什么是大小端？

> 大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
>
> 小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。

举例：存储一个数$0x11223344$。

<img src="C:\Users\31866\Pictures\画图\无标题.png" alt="无标题" style="zoom:80%;" />

判断大小端：

```c
#include <stdio.h>

int main(void)
{
    int a = 1;

    if (*(char *)&a == 1)
        printf("小端\n");
    else
        printf("大端\n");

    return 0;
}
```

升级版：

```c
int check_sys(void)
{
    int a = 1;

    return *(char *)&a; // 返回第一个字节，如果是1，就返回1；是0，就返回0
}
```

因为指针所指向的是从低地址指向高地址的第一个字节的地址，所以当指向4个字节的整形指针被截断为指向第一个字节的字符指针，该指针所指向的就是存在内存中的第一个字节的地址，也就是一个字节的内容。此时如果是小端字节序，低位存在低地址，就会显示`1`，而如果是大端字节序，高位存储在低地址，就会显示`0`。
