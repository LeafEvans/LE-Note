# 1.为什么使用文件

使用文件我们可以将数据直接存放在电脑的硬盘上，做到了数据的持久化。我们一般数据持久化的方法有，把数据存放在磁盘文件、存放在数据库等方式。

# 2.什么是文件

磁盘上的文件是文件。

但是在程序设计中，我们谈的文件分为两种：程序文件和数据文件（从文件功能角度来分类）

## 2.1 程序文件

> 包括源程序文件（后缀为.c），目标文件（windows环境后缀为.obj），可执行程序（windows环境后缀为.exe）。

## 2.2 数据文件

> 文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。

之前所处理数据的输入输出都是以终端为对象的，即从终端的键盘输入数据，运行结果到显示器上。

其实有时候我们也会把信息输出到磁盘上，当需要的时候再从磁盘上把数据读取到内存上使用，这里处理的就是磁盘上的文件。

# 2.3 文件名

一个文件要有一个唯一的文件标识，以便用户识别和引用。

文件名包含3部分：文件路径+文件名主干+文件后缀

例如：`c:\code\test.txt`

为了方便起见，文件标识常被称为**文件名**。

# 3.文件的打开和关闭

## 3.1 文件指针

缓冲文件系统中，关键的概念是**文件类型指针**，简称**文件指针**。

每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息（如文件的名字、文件状态及文件当前的位置等）。这些信息是保存在一个结构体变量中的。该结构体是有系统声明的，取名**FILE**。

每当打开一个文件的时候，系统会根据文件的情况自动创建一个FILE结构的变量，并填充其中的信息，使用者不必关心细节。

一般都是通过一个FILE的指针来维护这个FILE结构的变量，这样使用起来更加方便。

下面我们可以创建一个FILE*的指针变量：

```c
FILE* pf;  // 文件指针变量
```

定义pf是一个指向FILE类型数据的指针变量。可以使pf指向某个文件的文件信息区（是一个结构体变量）。通过该文件信息区中的信息就能访问该文件。也就是说，**通过文件指针变量能够找到与它相关联的文件**。

## 3.2 文件的打开和关闭

头文件为`<stdlib.h>`。

文件在读写之前应该先**打开文件**，在使用结束之后应该**关闭文件**。

编写程序时，在打开文件的同时，都会返回一个FILE*的指针变量指向该文件，也相当于建立了指针和文件的关系。

ANSIC规定使用`fopen`函数来打开文件，`fclose`来关闭文件。

```c
// 打开文件
FILE *fopen(const char* filename, const char *mode);
// 关闭文件
int fclose(FILE *stream);
```

`mode`指的是文件的打开模式，有：

![image-20231223195435002](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2F128bbd41006a850b7adcca6ca92256fb--4eaa--image-20231223195435002.png)

部分正确翻译：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Fb286694e8c49e420aae4784f56d82aec--8a35--image-20231223195917001.png" alt="image-20231223195917001" style="zoom:80%;" />

例如：

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test.txt", "r");
  if (pf == NULL) {
    printf("%s\n", strerror(errno));
    return 1;
  }
  fclose(pf);  // 类似free
  pf = NULL;
  return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Fa22f65e24f09cca80edad28b67007d6d--d1d6--image-20231223200341450.png" alt="image-20231223200341450" style="zoom:80%;" />

可以看出，没有这个文件。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Ffa517de81f86405cbda284f8385a8b1c--05fb--image-20231223201908031.png" alt="image-20231223201908031" style="zoom:80%;" />

# 4.文件的顺序读取

注意：以下的输入、输出是以内存为第一人称的，不是其他外部设备。输出指的是从内存输出进外部设备，输入指的是从外部设备输入内存。（所以是出、入）

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2F89c2fb40a4a31c58125a3be12c256ac3--b9d3--image-20231223202813401.png" alt="image-20231223202813401" style="zoom:80%;" />

--------

`int fputc ( int character, FILE * stream );`

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test_1.txt", "w");
  if (pf == NULL) {
    printf("%s\n", strerror(errno));
    return 1;
  }
  for (int i = 'a'; i <= 'z'; ++i) {
    fputc(i, pf);
  }
  fclose(pf);
  pf = NULL;
  return 0;
}
```

![image-20231223203632018](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2F46cee47ef54988e9abeb2d3ff05a6ecb--9fb1--image-20231223203632018.png)

---------

`int fgetc ( FILE * stream );`

`fgetc()`函数每次读取一个字符，并将文件位置指示器向前移动一个位置。如果文件中没有更多字符可以读取，`fgetc()`会返回EOF（End Of File）。

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test_1.txt", "r");
  if (pf == NULL) {
    printf("%s\n", strerror(errno));
    return 1;
  }
  int ch = fgetc(pf);
  printf("%c\n", ch);
  ch = fgetc(pf);
  printf("%c\n", ch);
  ch = fgetc(pf);
  printf("%c\n", ch);
  ch = fgetc(pf);
  printf("%c\n", ch);
  fclose(pf);
  pf = NULL;
  return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2F72424e5176cda1785c36076120b8f9ad--d077--image-20231223204250246.png" alt="image-20231223204250246" style="zoom:80%;" />

这样更好理解些（打印在终端都一样）：

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test_1.txt", "r");
  if (pf == NULL) {
    printf("%s\n", strerror(errno));
    return 1;
  }
  printf("%c\n", fgetc(pf));
  printf("%c\n", fgetc(pf));
  printf("%c\n", fgetc(pf));
  printf("%c\n", fgetc(pf));
  fclose(pf);
  pf = NULL;
  return 0;
}
```

一个示例：

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test_1.txt", "r");
  if (pf == NULL) {
    printf("%s\n", strerror(errno));
    return 1;
  }
  int ch = 0;
  while ((ch = fgetc(pf)) != EOF) printf("%c ", ch);
  fclose(pf);
  pf = NULL;
  return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Fb3bef3ef4da25169b3c95f68c9870f16--e027--image-20231223204907325.png" alt="image-20231223204907325" style="zoom:80%;" />

----------

`int fputs ( const char * str, FILE * stream );`

将 str 指向的 C 字符串写入数据流。

函数从指定的地址（str）开始复制，直到到达终止空字符（'\0'）。这个终止的空字符不会被复制到数据流中。

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test_1.txt", "w");
  if (pf == NULL) {
    printf("%s\n", strerror(errno));
    return 1;
  }
  fputs("hello world", pf);
  fclose(pf);
  pf = NULL;
  return 0;
}
```

![image-20231223205521434](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Ffe8312dcf5657e5d1c90611729125ef4--bda6--image-20231223205521434.png)

写文件时，它会把文件内容销毁，然后重新添加。因此改成`a`模式，便可以追加。

--------------

```
char * fgets ( char * str, int num, FILE * stream );
```

从数据流中获取字符串

从数据流中读取字符，并将其作为 C 语言字符串存储到 str 中，直到（num-1）个字符被读取，或者出现换行符或文件结束符，以先发生者为准。

换行符会使 fgets 停止读取，但函数会将其视为有效字符，并将其包含在复制到 str 的字符串中。

在复制到 str 的字符后，会自动添加一个结束符空字符。

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test_12_23.txt", "r");
  if (pf == NULL) printf("%s\n", strerror(errno));
  char arr[20] = {0};
  fgets(arr, 5, pf);
  printf("%s\n", arr);
  fclose(pf);
  pf = NULL;
  return 0;
}
```

因此虽然指定了5个，最后也只有4个，因为最后一个要放换行符。

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Fd63d36e368c7e873401a06a093ca0c6f--db9b--image-20231223211332554.png" alt="image-20231223211332554" style="zoom:80%;" />

读取失败或遇到文件末尾会返回一个空指针。

----------------------------

扩展：

`perror`函数可替代`scanf("%s\n", strerror(errno));`。

```c
void perror ( const char * str );
```

打印错误信息
将 errno 的值解释为错误信息，并将其打印到 stderr（标准错误输出流，通常是控制台），可选择在其前面加上 str 中指定的自定义信息。

errno 是一个积分变量，其值描述了调用库函数时产生的错误条件或诊断信息（C 标准库的任何函数都可以设置 errno 值，即使没有在本引用中明确指定，也即使没有发生错误），更多信息请参阅 errno。

perror 产生的错误信息与平台有关。

如果参数 str 不是空指针，则打印 str 后的冒号（:）和空格。然后，无论 str 是否是空指针，都会打印出生成的错误描述，后面跟一个换行符（'\n'）。

perror 应在错误发生后立即调用，否则会被其他函数的调用覆盖。

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main(void) {
  FILE *pf = fopen("test_12_23.txt", "r");
  if (pf == NULL) perror("");
  char arr[20] = {0};
  fgets(arr, 20, pf);
  printf("%s\n", arr);
  fclose(pf);
  pf = NULL;
  return 0;
}
```

输出与原来的相同。当然，也可以`perror("fopen");`，来表示错误信息出于何处。

有：

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Fd31731302e667bb002f1a970ddd0b1b4--c1c6--image-20231223212320378.png" alt="image-20231223212320378" style="zoom:80%;" />

自动添加冒号。但是它会自动打印，如果只想拿到错误信息，就使用`strerror`即可。

-----------------------------

```c
int fprintf( FILE *stream, const char *format [, argument ]...);
```

```c
#include <stdio.h>

typedef struct Stu {
  char arr[10];
  int age;
  float score;
} Stu;

int main(void) {
  Stu s = {"zhangsan", 25, 50.5f};
  FILE* pf = fopen("test_12_23.txt", "w");
  if (pf == NULL) {
    perror("fopen");
    return 1;
  }
  fprintf(pf, "%s %d %f", s.arr, s.age, s.score);
  fclose(pf);
  return 0;
}
```

--------------------------------


```c
int fscanf( FILE *stream, const char *format [, argument ]... );
```

```c
#include <stdio.h>

typedef struct Stu {
  char arr[10];
  int age;
  float score;
} Stu;

int main(void) {
  Stu s = {"zhangsan", 25, 50.5f};
  FILE* pf = fopen("test_12_23.txt", "r");
  if (pf == NULL) {
    perror("fopen");
    return 1;
  }
  fscanf(pf, "%s %d %f", s.arr, &(s.age), &(s.score));
  printf("%s %d %f\n", s.arr, s.age, s.score);
  fclose(pf);
  return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Fec01d38404556b463b058b3da76ba8a5--b0b5--image-20231223214446501.png" alt="image-20231223214446501" style="zoom:80%;" />

-------

扩展：

打开文件时，会返回一个`FILE*`的指针，这个值可以称为文件流。

但是使用`printf`和`scanf`时，不用打开或者关闭，为什么？因为C程序运行起来后，会默认打开三个流，

- `FILE* stdin` - 标准输入流（键盘）
- `FILE* stdout` - 标准输出流（屏幕）
- `FILE* stderr` - 标准错误流（屏幕）

因此可以用` fprintf(stdout, "%s %d %f\n", s.arr, s.age, s.score);`代替`printf`语句。

类似的函数：

- `sscanf`
- `sprintf`

它们第一个参数所指向的指针是字符串。

`scanf`是针对标准输入的格式化输出语句

`printf`是针对标准输出的格式化输出语句

`fscanf`是针对所有输出流的格式化输入语句

`fprintf`是针对所有输出流的格式化输出语句

`sscanf`从一个字符串中转换出一个格式化的数据

`sprintf`是把一个格式化的数据转换成字符串

-------

```c
size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );
```

**buffer**:

要写入数据的指针

**size**:

项目大小（字节）

**count**:

要写入的项目的最大数目

**stream**:

指向 FILE 结构的指针

```c
#include <stdio.h>

typedef struct Stu {
  char arr[10];
  int age;
  float score;
} Stu;

int main(void) {
  Stu s = {"zhangsan", 25, 50.5f};
  FILE* pf = fopen("test_12_23.txt", "r");
  if (pf == NULL) {
    perror("fopen");
    return 1;
  }
  fscanf(pf, "%s %d %f", s.arr, &(s.age), &(s.score));
  fprintf(stdout, "%s %d %f\n", s.arr, s.age, s.score);
  fclose(pf);
  return 0;
}
```

![image-20231223223307723](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-23%2Fa4bcc6d0e5e0d6ddbe38d33beef219a2--4eab--image-20231223223307723.png)

--------------------

类似的：

```c
size_t fread( void *buffer, size_t size, size_t count, FILE *stream );
```

```c
#include <stdio.h>

typedef struct Stu {
  char arr[10];
  int age;
  float score;
} Stu;

int main(void) {
  Stu s = {0};
  FILE* pf = fopen("test_12_23.txt", "rb");
  if (pf == NULL) {
    perror("fopen");
    return 1;
  }
  fread(&s, sizeof(Stu), 1, pf);
  printf("%s %d %f\n", s.arr, s.age, s.score);
  fclose(pf);
  pf = NULL;
  return 0;
}
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-12-24%2Fa5a24b07ed8ee8ec6f57325473a24271--8d03--image-20231224091938148.png" alt="image-20231224091938148" style="zoom:80%;" />
