# 1.b=a++和b=++a的区别

```c
#include <stdio.h>

int main(void)
{
	int a = 1, b = 1;
    
	b = a++;
	printf("%d %d", a, b);
    
	return 0;
}
```
上述代码属于先将把b的值赋值给a，然后a再进行+1的运算；最终会输出$2$ $1$；
```c
#include <stdio.h>

int main(void)
{
	int a = 1, b = 1;
    
	b = ++a;
	printf("%d %d", a, b);
    
	return 0;
}
```
上述代码先执行给a+1的操作，然后再将a的值赋值给b，会输出$2$ $2$；
```c
return n++;
return ++n;
return n + 1;
```
上述代码中，第1行仅会返回n，因为++运算符放在之后，会先返回再++；第2行和第3行都会正确执行想要的操作。

在函数传参中也是相同的效果。

# 2.分数运算
```c
#include <stdio.h>

int main(void)
{
	printf("%f", 4.0/3);
    
	return 0;
}
```
如果要输出$4/3$的结果的小数，$4$或$3$其中一个要写成如$4.0$或$3.0$这种形式，才会输出$1.333333$。将其中一个操作数替换为浮点型来进行计 算。

# 3.算术操作符

```C
+ - / * %
```

在C语言中，整数运算时的取整运算是向0取整，如：

```c
#include <stdio.h>

int main(void)
{
    int a = -10;
    int b = 3;
    
    printf("%d\n", a / b);
    printf("%d\n", a % b);
    
    return 0;
}
```

会输出：

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231025224154446.png" alt="image-20231025224154446" style="zoom:80%;" />

对于取模操作符，它的两个操作数必须是整数。此外，从上述输出可以看出，取模的操作具体定义如下：

> 如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数q和r，满足$a = q * d + r$ 且$0<=|r|<|d|$。其中q被称为商，r被称为余数。

上述计算可以解释为：$-10=(-3)*3+(-1)$。

其中，$-1$为取模的值。

# 4.条件运算符

条件运算符（三目操作符）根据条件选择返回两个值之一。

语法如下：

```c
条件表达式 ? 结果1 : 结果2
```
结果1是当条件表达式成立的时候会运行的语句(即条件真)，而结果2是当条件表达是不成立时会运行的语句（即条件假）。

如：

```c
#include <stdio.h>

int main(void) 
{
    int x = 5;
    int y = (x > 0) ? 10 : -10;

    printf("y = %d\n", y);

    return 0;
}
```
上述代码$x>5$成立，运行结果$1$，即返回一个$10$的值。最终输出$10$。

# 5.逗号表达式
逗号表达式从左向右每个语句都会执行，但最终返回的是最后一个语句的结果。

语法如下：

```c
表达式1, 表达式2, 表达式3, ..., 表达式n
```
代码示例：
```c
#include <stdio.h>

int main(void) 
{
    int x = 5, y = 10, z;
    
    z = (x++, y++, x + y); // 逗号表达式中的x++和y++会被依次执行，最后的结果是x+y赋给z
    printf("z = %d\n", z);

    return 0;
}
```
最终会输出$17$。
# 6.逻辑操作符
```C
&& 逻辑与
|| 逻辑或
```

两者输出的结果为$0$或$1$。

```c
#include <stdio.h>

int main(void)
{
    int i = 0, a = 0, b = 2, c = 3, d = 4;

    i = a++ && ++b && d++;
    printf("a = %d\nb = %d\nc = %d\nd = %d\n");
    // 因为逻辑运算符是从左向右运算的
    // 上述代码中，因a = 0，所以使得左边为假，整体为假，导致右边的表达式不进行运算
    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{
    int i = 0, a = 1, b = 2, c = 3, d = 4;

    i = a++ || ++b || d++;
    printf("a = %d\nb = %d\nc = %d\nd = %d\n");
    // 因为最左边的表达式为真，整体为真
    // 所以在算完第一个表达式后，不再进行后面表达式的计算
    return 0;
}
```

对于`&&`,左边为假，右边不计算；对于`||`，左边为真，右边不计算。

# 7.位操作符

这些运算符与二进制有关。

正整数的原码、反码、补码是相同的；负整数的原码、反码、补码是要计算的。

而整数在内存中存的是补码。

## （1）&
位与运算：
```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", 3 & 2);
    
    return 0;
}
```
上述代码会输出$2$。

因为：

```c
0000 0011
0000 0010
// 进行位与运算
0000 0010
=2
```
## （2）|
位或运算：
```c
#include <stdio.h>

int main(void)
{
	printf("%d\n", 3 | 2);
    
	return 0;
}
```
上述代码会输出$3$。

因为：

```c
0000 0000 0000 0011
0000 0000 0000 0010
// 进行位或运算
0000 0011
=3
```
## （3）~
按位取反：
```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", ~2);
    
    return 0;
}
```
上述代码会输出$-7$。

因为：

```c
0000 0000 0000 0010
// 进行按位取反
1111 1111 1111 1101
=-7
```
## （4）^
异或运算：
```c
#include <stdio.h>

int main(void)
{
	printf("%d\n", 3 ^ 2);
  
	return 0;
}
```
上述代码会输出$1$。

因为：

```c
0000 0000 0000 0011
0000 0000 0000 0010
// 进行异或运算
0000 0000 0000 0001
=1
```
## （5）<<
左移运算：
```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", 3 << 2); // 代表整体移动两位，抛弃最左侧，往最右边添上0
  
    return 0;
}
```
上述代码会输出$12$。

因为：

```c
0000 0000 0000 0011
// 进行左移运算
0000 0000 0000 1100
=12
```
左移操作符代表$*2$两次。

需要注意的是，左移操作符以及右移操作符只针对整数，并且移动的位数必须是正整数。

## （6）>>

右移运算分为两种：

- 算数移位：右边丢弃，左边补原符号位
- 逻辑移位：右边丢弃，左边补0

```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", 4 >> 1);
  
    return 0;
}
```
上述代码会输出$2$。

VS编辑器采用的是算数移位。

因为:

```c
0000 0000 0000 0100
// 进行右移运算
0000 0000 0000 0010
=2
```

举例：

```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", -7 >> 1);
  
    return 0;
}
```

上述代码会输出$-4$。

## （7）相关例题

- 在不创建临时变量的情况下，交换两个量。

  1. ```c
     #include <stdio.h>
     
     int main(void)
     {
         int a = 3;
         int b = 5;
     
         a = a + b; // 把a赋值成a + b
         b = a - b; // 此时a + b - b就等于a
         a = a - b; // a + b减去已经是a的b，就是b原来的值
     
         return 0;
     }
     // 但这个方法有溢出的危险
     ```

  2. 首先，有两个公式$a⊕a=0$和$a⊕0=a$，且满足交换率，因此有：

     ```c
     #include <stdio.h>
     
     int main(void)
     {
         int a = 3;
         int b = 5;
     
         a = a ^ b; // a = 3 ^ 5
         b = a ^ b; // b = 3 ^ 5 ^ 5 = 3 ^ 0 = 3
         a = a ^ b; // a = 3 ^ 5 ^ 3 = 5 ^ 0 = 5
     
         return 0;
     }
     // 需要注意的是该种方法运行速度较慢，而且只适用于整形
     ```
     

- 编写代码实现：求一个整数存储在内存中的二进制中1的个数（求补码的二进制中1的个数）。

  首先需要知道，与1进行与运算的数，如果表示为二进制时的LSB为1，则运算结果为1；反之，运算结果为0。

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      int n = 0;
      int i = 0;
      int sum = 0;
  
      scanf("%d", &n);
      for (i = 0; i < 32; i++)
      {
          sum += n & 1; // 每个数与1进行与运算，如果那个数的LSB为1，则返回1；反之，返回0
          n >>= 1;      // 进行右移运算，根据循环进行32次，更新LSB
      }
  
      return 0;
  }
  ```


# 8.赋值运算符

```c
int a = 1; // 初始化
a = 2;     // 赋值，两者不相同
```

赋值运算符可以连续使用：

```c
a = x = y + 1; // 连续赋值
a = (x = y + 1); 
```

上述代码表示：

先将$y+1$的值赋给了$x$，再将$x$的值赋给了$a$。

复合赋值符：

```c
+=
-=
*=
%=
>>=
<<=
&=
|=
^=  
```

# 9.单目操作符

与双目操作符不同，单目操作符只有一个操作数。

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231026195905494.png" alt="image-20231026195905494" style="zoom:80%;" />

举例：

```c
a &= (~(1 << 4)); // 1 & a = a
a |= (1 << 4); // 0 | a = a
```

1. `a &= (~(1 << 4));`: 这行代码将 `a` 与 `~(1 << 4)` 的按位与结果进行赋值操作。首先，`1 << 4` 将二进制数 1 左移 4 位，得到二进制数 00010000。然后，`~(1 << 4)` 对这个结果取反，得到二进制数 11101111。最后，`a &= (~(1 << 4))` 将 `a` 与 11101111 进行按位与操作，即将 `a` 的第 5 位设置为 0，其他位保持不变。
2. `a |= (1 << 4);`: 这行代码将 `a` 与 `1 << 4` 的按位或结果进行赋值操作。同样地，`1 << 4` 得到二进制数 00010000。然后，`a |= (1 << 4)` 将 `a` 与 00010000 进行按位或操作，即将 `a` 的第 5 位设置为 1，其他位保持不变。

```C
sizeof a == sizeof(a);
sizeof(int);
```

可以看出它不是函数而且可以计算数据类型的大小。

（注意：`%zu`是用来返回`sizeof`值的转换说明。）

# 10.下标引用、函数调用和结构成员

## （1）[]下标引用操作符

> 操作数：一个数组名 + 一个索引值
>

```c
int arr[10];
arr[9] = 10;
// 本质是*(arr+9)，满足交换律
// []的两个操作数是arr和9。
9[arr] = 8; // 因为它是一个操作符，所以也是可以实现的
```

上述代码中，$9$代表9个元素的偏移量，每个单位的偏移量的大小由数据类型决定，才能使加上相应的偏移量指向相应的地址。

> - `char`：1 字节
> - `short`：2 字节
> - `int`：4 字节
> - `long`：4 或 8 字节（取决于平台）
> - `float`：4 字节
> - `double`：8 字节

例如，如果有一个 `int` 类型的数组 `arr`，那么 `arr+1` 的偏移量将是 4 字节，因为 `int` 类型占用 4 个字节。

对于其他类型的数组，也是类似的原理。根据数组元素的类型确定每个单位的偏移量大小。请注意，这里的单位是指数组元素的个数，而不是字节。

需要注意的是，**指针的加法操作是基于指针类型的大小来计算偏移量的**。因此，在进行指针运算时要确保不会越界访问数组元素。

## （2）()函数调用操作符

接受一个或多个操作数：第一个操作数是函数名，剩余的操作数就是传给函数的参数。

> . 结构体.成员名
> -> 结构体指针->成员名

```c
#include <stdio.h>

struct Stu
{
char name[10];
int age;
char sex[5];
double score;
}；

void set_age1(struct Stu stu)
{
stu.age = 18;
}

void set_age2(struct Stu* pStu)
{
pStu->age = 18; // 结构成员访问
}

int main(void)
{
struct Stu stu;
struct Stu* pStu = &stu; // 结构成员访问
  
stu.age = 20; // 结构成员访问
set_age1(stu);
pStu->age = 20; // 结构成员访问
set_age2(pStu);

return 0;
}

```

# 11.表达式求值

## （1）隐式类型转换

C的整型算术运算总是至少以缺省整型类型的精度来进行的。

只要在表达式中，如`a == 111111`、`c = a + b`、`+c`，就会整形提升。

为了获得这个精度，表达式中的字符（char）和短整型（short）操作数在使用之前被转换为普通整型，这种转换称为整型提升。

整形提升的意义：

> 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器（ALU）的操作数的字节长度
>
> 一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
>
> 因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
>
> 通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。
>
> 所以，表达式中各种长度可能小于int长度的整型值，
>
> 都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。

```c
char a, b, c;
a = b + c;
```

因为1个字符用1byte表示，而一个整形用4bype表示，所以要整形提升。

b和c的值被提升为普通整型，然后再执行加法运算。

加法运算完成之后，结果将被截断，然后再存储于a中。

> 整形提升是按照变量的数据类型的符号位来提升的

```c
// 负数的整形提升
char c1 = -1;
// 变量c1的二进制位（补码）中只有8个比特位：
1111111
/*因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为1
提升之后的结果是：*/
11111111111111111111111111111111
// 正数的整形提升
char c2 = 1;
// 变量c2的二进制位（补码）中只有8个比特位：
00000001
// 因为 char 为有符号的 char
// 所以整形提升的时候，高位补充符号位，即为0
// 提升之后的结果是：
00000000000000000000000000000001
// 无符号整形提升，高位补0
```

例子：

```c
#include <stdio.h>

int main(void)
{									     // 存进去的时候要截断
    char a = 5;        // 00000000000000000000000000000101 -> 00000101
    char b = 126;      // 00000000000000000000000001111110 -> 01111110
    char c = a + b;    // 两个数进行整形运算时要进行整形提升
										   // 00000000000000000000000010000111 -> 10000111
    printf("%d\n", c); // 算完之后再打印，有一次进行整型提升
											 // 11111111111111111111111110000111（1被当成符号位了，根据原则补1，这是补码）
    return 0;          // 最后按照%d输出-125，而不是131
}
```

输出：

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231029231957206.png" alt="image-20231029231957206" style="zoom:80%;" />

## （2）算术转换

如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。

下面的层次体系称为寻常算术转换。

其中一个操作数向着大的类型转换，如`int`转换成`long`、`float`之类的。

```c
long double
double
float
unsigned long int
long int
unsigned int
int
```

注意：

```c
float f = 3.14;
int num = f; // 隐式转换，会有精度差异
```

## （3）操作符的属性

复杂表达式的求值有三个影响的因素。

1. 操作符的优先级
2. 操作符的结合性
3. 是否控制求值顺序。

两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

```c
// 表达式的求值部分由操作符的优先级决定。
// 表达式1
a * b + c * d + e * f
```

> 注释：代码1在计算的时候，由于比+的优先级高，只能保证，的计算是比+早，但是优先级并不能决定第三个*比第一个+早执行。

例1：

```c
a  *b
c * d
a * b + c * d
e * f
a * b + c * d + e * f
```

或者：

```c
a * b
c * d
e * f
a * b + c * d
a * b + c * d + e * f
```

例2：

```c
int fun()
{
static int count = 1;
return ++count;
}

int main(void)
{
int answer;
  
answer = fun() - fun() * fun();
printf( "%d\n", answer); // 输出多少？
  
return 0;
}
```

虽然在大多数的编译器上求得结果都是相同的。

但是上述代码`answer = fun() - fun() * fun()`; 中我们只能通过操作符的优先级得知：

先算乘法，再算减法。

函数的调用先后顺序无法通过操作符的优先级确定。
