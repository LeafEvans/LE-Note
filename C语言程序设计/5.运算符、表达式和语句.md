# 1.b=a++和b=++a的区别

```c
#include <stdio.h>

int main(void)
{
	int a = 1, b = 1;
    
	b = a++;
	printf("%d %d", a, b);
    
	return 0;
}
```
上述代码属于先将把b的值赋值给a，然后a再进行+1的运算；最终会输出$2$ $1$；
```c
#include <stdio.h>

int main(void)
{
	int a = 1, b = 1;
    
	b = ++a;
	printf("%d %d", a, b);
    
	return 0;
}
```
上述代码先执行给a+1的操作，然后再将a的值赋值给b，会输出$2$ $2$；
```c
return n++;
return ++n;
return n + 1;
```
上述代码中，第1行仅会返回n，因为++运算符放在之后，会先返回再++；第2行和第3行都会正确执行想要的操作。

在函数传参中也是相同的效果。

# 2.分数运算
```c
#include <stdio.h>

int main(void)
{
	printf("%f", 4.0/3);
    
	return 0;
}
```
如果要输出$4/3$的结果的小数，$4$或$3$其中一个要写成如$4.0$或$3.0$这种形式，才会输出$1.333333$。将其中一个操作数替换为浮点型来进行计 算。

# 3.算术操作符

```C
+ - / * %
```

在C语言中，整数运算时的取整运算是向0取整，如：

```c
#include <stdio.h>

int main(void)
{
    int a = -10;
    int b = 3;
    
    printf("%d\n", a / b);
    printf("%d\n", a % b);
    
    return 0;
}
```

会输出：

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231025224154446.png" alt="image-20231025224154446" style="zoom:80%;" />

对于取模操作符，它的两个操作数必须是整数。此外，从上述输出可以看出，取模的操作具体定义如下：

> 如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数q和r，满足$a = q * d + r$ 且$0 <= |r| < |d|$。其中q被称为商，r被称为余数。

上述计算可以解释为：$-10 = (-3) * 3 + (-1)$。

其中，$-1$为取模的值。

# 4.条件运算符

条件运算符(三目操作符)根据条件选择返回两个值之一。

语法如下：

```c
条件表达式 ? 结果1 : 结果2
```
结果1是当条件表达式成立的时候会运行的语句(即条件真)，而结果2是当条件表达是不成立时会运行的语句(即条件假)。

如：

```c
#include <stdio.h>

int main(void) 
{
    int x = 5;
    int y = (x > 0) ? 10 : -10;

    printf("y = %d\n", y);

    return 0;
}
```
上述代码$x > 5$成立，运行结果$1$，即返回一个$10$的值。最终输出$10$。

# 5.逗号表达式
逗号表达式从左向右每个语句都会执行，但最终返回的是最后一个语句的结果。

语法如下：

```c
表达式1, 表达式2, 表达式3, ..., 表达式n
```
代码示例：
```c
#include <stdio.h>

int main(void) 
{
    int x = 5, y = 10, z;
    
    z = (x++, y++, x + y); // 逗号表达式中的x++和y++会被依次执行，最后的结果是x+y赋给z
    printf("z = %d\n", z);

    return 0;
}
```
最终会输出$17$。
# 6.逻辑操作符
```C
&& 逻辑与
|| 逻辑或
```

两者输出的结果为$0$或$1$。

```c
#include <stdio.h>

int main(void)
{
    int i = 0, a = 0, b = 2, c = 3, d = 4;

    i = a++ && ++b && d++;
    printf("a = %d\nb = %d\nc = %d\nd = %d\n");
    // 因为逻辑运算符是从左向右运算的
    // 上述代码中，因a = 0，所以使得左边为假，整体为假，导致右边的表达式不进行运算
    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{
    int i = 0, a = 1, b = 2, c = 3, d = 4;

    i = a++ || ++b || d++;
    printf("a = %d\nb = %d\nc = %d\nd = %d\n");
    // 因为最左边的表达式为真，整体为真
    // 所以在算完第一个表达式后，不再进行后面表达式的计算
    return 0;
}
```

对于`&&`,左边为假，右边不计算；对于`||`，左边为真，右边不计算。

# 7.位操作符

这些运算符与二进制有关。

正整数的原码、反码、补码是相同的；负整数的原码、反码、补码是要计算的。

而整数在内存中存的是补码。

## (1)&
位与运算：
```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", 3 & 2);
    
    return 0;
}
```
上述代码会输出$2$。

因为：

```c
0000 0011
0000 0010
// 进行位与运算
0000 0010
=2
```
## (2)|
位或运算：
```c
#include <stdio.h>

int main(void)
{
	printf("%d\n", 3 | 2);
    
	return 0;
}
```
上述代码会输出$3$。

因为：

```c
0000 0000 0000 0011
0000 0000 0000 0010
// 进行位或运算
0000 0011
=3
```
## (3)~
按位取反：
```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", ~2);
    
    return 0;
}
```
上述代码会输出$-7$。

因为：

```c
0000 0000 0000 0010
// 进行按位取反
1111 1111 1111 1101
=-7
```
## (4)^
异或运算：
```c
#include <stdio.h>

int main(void)
{
	printf("%d\n", 3 ^ 2);
  
	return 0;
}
```
上述代码会输出$1$。

因为：

```c
0000 0000 0000 0011
0000 0000 0000 0010
// 进行异或运算
0000 0000 0000 0001
=1
```
## (5)<<
左移运算：
```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", 3 << 2); // 代表整体移动两位，抛弃最左侧，往最右边添上0
  
    return 0;
}
```
上述代码会输出$12$。

因为：

```c
0000 0000 0000 0011
// 进行左移运算
0000 0000 0000 1100
=12
```
左移操作符代表$*2$两次。

需要注意的是，左移操作符以及右移操作符只针对整数，并且移动的位数必须是正整数。

## (6)>>

右移运算分为两种：

- 算数移位：右边丢弃，左边补原符号位
- 逻辑移位：右边丢弃，左边补0

```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", 4 >> 1);
  
    return 0;
}
```
上述代码会输出$2$。

VS编辑器采用的是算数移位。

因为:

```c
0000 0000 0000 0100
// 进行右移运算
0000 0000 0000 0010
=2
```

举例：

```c
#include <stdio.h>

int main(void)
{
    printf("%d\n", -7 >> 1);
  
    return 0;
}
```

上述代码会输出$-4$。

## (7)相关例题

- 在不创建临时变量的情况下，交换两个量。

  1. ```c
     #include <stdio.h>
     
     int main(void)
     {
         int a = 3;
         int b = 5;
     
         a = a + b; // 把a赋值成a + b
         b = a - b; // 此时a + b - b就等于a
         a = a - b; // a + b减去已经是a的b，就是b原来的值
     
         return 0;
     }
     // 但这个方法有溢出的危险
     ```

  2. 首先，有两个公式$a⊕a=0$和$a⊕0=a$，且满足交换率，因此有：

     ```c
     #include <stdio.h>
     
     int main(void)
     {
         int a = 3;
         int b = 5;
     
         a = a ^ b; // a = 3 ^ 5
         b = a ^ b; // b = 3 ^ 5 ^ 5 = 3 ^ 0 = 3
         a = a ^ b; // a = 3 ^ 5 ^ 3 = 5 ^ 0 = 5
     
         return 0;
     }
     // 需要注意的是该种方法运行速度较慢，而且只适用于整形
     ```
     

- 编写代码实现：求一个整数存储在内存中的二进制中1的个数(求补码的二进制中1的个数)。

  首先需要知道，与1进行与运算的数，如果表示为二进制时的LSB为1，则运算结果为1；反之，运算结果为0。

  ```c
  #include <stdio.h>
  
  int main(void)
  {
      int n = 0;
      int i = 0;
      int sum = 0;
  
      scanf("%d", &n);
      for (i = 0; i < 32; i++)
      {
          sum += n & 1; // 每个数与1进行与运算，如果那个数的LSB为1，则返回1；反之，返回0
          n >>= 1;      // 进行右移运算，根据循环进行32次，更新LSB
      }
  
      return 0;
  }
  ```


# 8.赋值运算符

```c
int a = 1; // 初始化
a = 2;     // 赋值，两者不相同
```

赋值运算符可以连续使用：

```c
a = x = y + 1; // 连续赋值
a = (x = y + 1); 
```

上述代码表示：

先将$y+1$的值赋给了$x$，再将$x$的值赋给了$a$。

复合赋值符：

```c
+=
-=
*=
%=
>>=
<<=
&=
|=
^=  
```

# 9.单目操作符

与双目操作符不同，单目操作符只有一个操作数。

<img src="C:\Users\31866\AppData\Roaming\Typora\typora-user-images\image-20231026195905494.png" alt="image-20231026195905494" style="zoom:80%;" />

举例：

```c
a &= (~(1 << 4)); // 1 & a = a
a |= (1 << 4); // 0 | a = a
```

1. `a &= (~(1 << 4));`: 这行代码将 `a` 与 `~(1 << 4)` 的按位与结果进行赋值操作。首先，`1 << 4` 将二进制数 1 左移 4 位，得到二进制数 00010000。然后，`~(1 << 4)` 对这个结果取反，得到二进制数 11101111。最后，`a &= (~(1 << 4))` 将 `a` 与 11101111 进行按位与操作，即将 `a` 的第 5 位设置为 0，其他位保持不变。
2. `a |= (1 << 4);`: 这行代码将 `a` 与 `1 << 4` 的按位或结果进行赋值操作。同样地，`1 << 4` 得到二进制数 00010000。然后，`a |= (1 << 4)` 将 `a` 与 00010000 进行按位或操作，即将 `a` 的第 5 位设置为 1，其他位保持不变。

```C
sizeof a == sizeof(a);
sizeof(int);
```

可以看出它不是函数而且可以计算数据类型的大小。

# 10.下标引用、函数调用和结构成员

## 1.[]下标引用操作符

操作数：一个数组名+一个索引值

```c
int arr[10];
arr[9] = 10;
// 本质是*(arr+9)，满足交换律
// []的两个操作数是arr和9。
9[arr] = 8; // 因为它是一个操作符，所以也是可以实现的
```

上述代码中，$9$代表9个元素的偏移量，每个单位的偏移量的大小由数据类型决定，才能使加上相应的偏移量指向相应的地址。

> - `char`：1 字节
> - `short`：2 字节
> - `int`：4 字节
> - `long`：4 或 8 字节（取决于平台）
> - `float`：4 字节
> - `double`：8 字节

例如，如果有一个 `int` 类型的数组 `arr`，那么 `arr+1` 的偏移量将是 4 字节，因为 `int` 类型占用 4 个字节。

对于其他类型的数组，也是类似的原理。根据数组元素的类型确定每个单位的偏移量大小。请注意，这里的单位是指数组元素的个数，而不是字节。

需要注意的是，**指针的加法操作是基于指针类型的大小来计算偏移量的**。因此，在进行指针运算时要确保不会越界访问数组元素。

## 2.()函数调用操作符

接受一个或多个操作数：第一个操作数是函数名，剩余的操作数就是传给函数的参数。

> . 结构体.成员名
> -> 结构体指针->成员名

```c
#include <stdio.h>

struct Stu
{
char name[10];
int age;
char sex[5];
double score;
}；

void set_age1(struct Stu stu)
{
stu.age = 18;
}

void set_age2(struct Stu* pStu)
{
pStu->age = 18; // 结构成员访问
}

int main(void)
{
struct Stu stu;
struct Stu* pStu = &stu; // 结构成员访问
  
stu.age = 20; // 结构成员访问
set_age1(stu);
pStu->age = 20; // 结构成员访问
set_age2(pStu);

return 0;
}

```

