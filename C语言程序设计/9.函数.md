# 1.Sleep函数
头文件为**<windows.h>**。

Windows系统中的函数。可以减缓程序运行的速度，当运行该语句时，如`Sleep(2000)`时，里面的数字代表停止2000毫秒。在Windows系统中要带有**<window.h>**的头文件，而在其他系统中要其他的头文件。S为大写。

# 2.system函数
头文件是**<stdlib.h>**。

**system**函数是Windows特有的库函数，执行系统命令。如在系统命令中，`system("cls")`代表清空命令控制台，其中`cls`为系统命令。执行一次会将整个终端原有输出内容清空。

还有系统命令如`shutdown = -s`代表关机，`shutdown = -s -t 60`代表60秒后关机，而`shutdown = -a`代表取消关机。

# 3.strcmp函数
头文件为**<string.h>**。

**strcmp**函数是用来判断字符是否相同的函数。如果相等，它就会返回0；不相等，反之。

如下列代码，

```C
if (str == strcmp("abc"))
{

}
```

# 4.rand函数、srand函数以及time函数
## （1）rand函数
头文件为**<stdlib.h>**。

用法示例：

| **v1 = rand() % 100** | **v1 取值范围 0~99** |
| --- | --- |
| **v2 = rand() % 100 + 1** | **v2 取值范围 1~100** |
| **v3 = rand() % 30 + 1985** | **v3 取值范围 1985~2014** |

**rand**函数是返回一个介于0和RAND_MAX(32767)之间的伪随机整数。

这个数字是由一个算法生成的，该算法每调用一次它就会产生一个毫不相关的数字序列。该算法是通过一个固定的种子来生成随机数的，因此每次运行时，产生的随机数也是相同的。

而**rand**函数返回值取模100，而任何一个整数除以100的余数范围在0\~99之间，而加1就能表示1~100的数。

代码示例：

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int i = 0;
    
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", rand() % 10);
    }
    system("pause");
    
    return 0;
}

```
运行上述代码时，它会将每一次循环所生成的随机数打印出来。而每一次运行程序的结果均为下图所示：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1695966632688-992da6db-cb96-4e7d-9286-a235075dbf46.png#averageHue=%23edebe9&clientId=ucd189e01-a949-4&from=paste&height=19&id=u00c324b3&originHeight=28&originWidth=579&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4088&status=done&style=none&taskId=u2b3b9f42-37ac-41a1-8b32-2176a5f3333&title=&width=386)

## （2）srand函数
头文件为**<stdlib.h>**。

**srand**函数是定义种子的函数，如果没有调用**srand**函数来初始化，系统会自动调用一次**srand**函数来初始化种子。每次循环初始化的种子不同，但每次运行程序时每个种子的顺序和数值都相同，导致上述结果相同。

因此要通过向**srand**函数输入一个随机值，使它随机返回一个种子，从而使**rand**函数产生一个随机值。而输入的随机值是时间戳。

```C
void srand(unsigned int seed);
```

可知**srand**函数需要输入的是一个无符号整形。

## （3）time函数
头文件为**<time.h>**。

```C
time_t time(time_t *timer);
```

简要介绍：

时间戳是指自协调世界时（UTC）1970年1月1日00:00:00开始经过的秒数，不考虑闰秒。Unix时间戳可以是正数或负数，其中正数表示1970年之后的时间，负数表示1970年之前的时间。

简而言之，时间戳就是一串可以代表时间的数字序列。而**time**函数的返回值类型为time_t，本质上是一个整形。而**srand**函数所需要的输入值是一个无符号整形，所以需要进行强制类型转换。而在强制类型转换中可能会有数据的丢失，但我们不要求精准的数字，只要求一个随机值，所以可以不用考虑。

而其输入值为一个指针变量，因此我们可以输入**NULL**（空指针）或者0。

代码示例：

```c
int main() 
{
	int i = 0;
    
	srand((unsigned int) time(0)); // 此处一定要注意，srand()一定不要写在生成随机数的函数中！
	for (int i = 0; i < 10; i++) 
	{
		printf("%d ", rand() % 10);
	}
	system("pause");
    
	return;
}
```
因为如果每次返回的时间间隔不超过一秒，就会返回一个相同的时间戳，从而返回一个相同的种子，从而导致每次生成的数都相同。

# 5.sqrt函数
头文件为**<math.h>**。

可以求一个**double**类型的数的平方根。

```C
double sqrt(double x);
```

# 6.实参和形参与传值调用和传址调用
函数传递参数可以传参数、函数和表达式（表达式可以是逗号表达式）。
## （1）实参和形参
案例：交换数字。

错误代码示例：

```c
#include <stdio.h>

void swap(int x, int y)
{
    int temp = x;
    x = y;
    y = temp;
}

int main(void)
{
    int a = 0, b = 0;

    scanf("%d %d", &a, &b);
    swap(a, b);
    printf("%d %d\n", a, b);

    return 0;
}
```
输入和输出结果：

```
10 40
10 40
```

因为再运行swap函数的时候，仅仅是把a和b的值传给了x和y，x和y新创建了两个与a和b不同的内存空间，x与y的值确实进行了交换，但不会影响a和b的值。

a和b是实际参数，x和y是形式参数。两者有不同的内存空间，修改形式参数不会影响实际参数。

（形参是实参的临时拷贝。）

正确代码示范：

```c
#include <stdio.h>

void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main(void)
{
    int a = 0, b = 0;

    scanf("%d %d", &a, &b);
    swap(&a, &b);
    printf("%d %d\n", a, b);

    return 0;
}
```
在上述代码中，传给swap函数的是两个指针变量，因此指针变量的形参的地址、与实参是否相同就不重要。再通过形参的地址与外部变量建立联系，用解引用来改变外部两个变量的值，从而实现交换的效果。

（因此，如果想对实参进行操作，就要取地址来进行操作。）

## （2）传值调用和传址调用
根据错误示范，传值调用让函数对形参进行修改，因为实参与形参有不同的内存块，所以对其的修改不会影响到实参。

而传址调用通过传递地址从而建立起内部与外部真正的联系。

而全局变量不用传参。

# 7.getchar函数、putchar函数
```c
#include <stdio.h>

int main()
{
 int ch = 0;
    
 while ((ch = getchar()) != EOF)
       putchar(ch);
    
    return 0;
}
```
**getchar()**便是读取键盘上输入的字符，而**putchar()**则是输出单个字符的工具。

上述代码实现了在键盘输入什么单个字符，就输出什么单个字符。

而**EOF**在键盘上表示为[Ctrl]+[z],当输入**EOF**时就会推出循环。（**EOF**本质是-1)

至于定义**ch**用整形是因为该函数的返回值是整形。用**int**既可以读取ASCII码值，也可以读取**EOF**。如果是用**char**类型就不能接收**EOF。**（**EOF**本质是-1）

在输出时会自动切换下一行，原因是比如输入字符**a**，需要按下回车[Enter]来使其触发。此时缓冲区中有字符**a**、**\n**。此时**getchar()**去读，就会读到两者（第一次循环是**a**，第二次循环是**\n**），之后分别两次由**putchar()**来输出**getchar()**读取的字符。

## （1）清理缓存区
经过简单的修改后，可以成为清理缓存区的工具。
```c
while ((ch = getchar()) != '\n')
{
	;
}
/*在循环中不断地用getchar()来读取字符，
 直到读取完"\n", 也就是缓存区的所有字符，
 才跳出循环*/
```
（额外知识：**scanf**不会读取空格、\n和制表符，当读到这些时，它会停止读取，因为它把它们当成了分隔符。）
## （2）打印数字字符
```c
#include <stdio.h>

int main(void)
{
	char ch = '0';
    
	while ((ch = getchar()) != EOF)
	{
		if (ch < '0' || ch>'9')
			continue;
		putchar(ch);
	}
    
	return 0;
}
```
 这个代码的作用是：只打印数字字符，跳过其他字符。（也可以类比到其他的字符。）
# 8.函数的声明与定义
如果要在后面定义函数，要满足先声明后使用，则要如下述代码：
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int Add(int, int); // 函数的声明

int main(void)
{
	int a = 0;
	int b = 0;
	int sum = Add(a, b);
    
	printf("%d\n", sum);
    
	return 0;
}

int Add(int x, int y) // 函数的定义
{
	return x + y;
}
```
（或者在声明处加上x和y与定义一致。）

函数的声明一般放在头文件中；

函数的定义一般放在源文件中。

两者形成一个模块。

因此，如上，创建一个`add.h`和`add.c`；

在原代码中，这样用：

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include "add.h"

int main(void)
{
	int a = 0;
	int b = 0;
	int sum = add(a, b);
    
	printf("%d\n", sum);
    
	return 0;
}

```
（额外：可以让代码编译成静态库，便于商业使用，而后将代码放入目录中，使用静态库时，使用下列的代码:

`#pragma comment(lib, "add.lib")`，

这是导入静态库的方法。）

# 9.函数递归
## 递归两个必要条件

- 存在限制条件，当满足这个限制条件的时候，递归便不再继续。
- 每次函数调用之后越来越接近这个限制条件。

## 例题
- 接受一个无符号整形（无符号），按照顺序打印它的每一位

```c
#include <stdio.h>

void print(unsigned int n)
{
    if (n > 9)
    {
        print(n / 10); // 通过递归，在满足n为个数的情况下，跳过if语句进行打印
    }                 // 而后，完成了if语句，再打印十位，完成一次print函数，以此类推
    printf("%d ", n % 10); // 自己调用自己，完成递归
}

int main(void)
{
    unsigned int num = 0;
    
    scanf("%d", &num);
    print(num);
    
    return 0;
}
```
- 编写函数不允许创建临时变量，求字符串的长度

```c
#include <stdio.h>

int my_strlen(char str[])
{
    if (*str != '\0')
        return 1 + my_strlen(str + 1);
        // 在递过程的最后是'\0',它返回0
        // 而后加上1个字符返回1
        // 然后，再1个字符返回1
        // 以此类推，每一个字符都返回1
        // 最终归到最开始的那一层，返回字符的数量
	// 扩展：如果是整形数组，str+1就代表移动四个字符，移动到下一个元素
    else
        return 0;
}

int main(void)
{
    char arr[] = "asda";

    printf("%d\n", my_strlen(arr));

    return 0;
}
```

- n!的阶乘

```c
int factorial(int n)
{
    if (n == 1)
        return 1;
    else if (n != 1)
        return n * factorial(n - 1);
}
```

$$
f(n) = 
	\begin{cases}
		1, & \text {n=1}\\
		nf(n-1), & \text {n>1}
	\end{cases}
$$

- 斐波那契数列

```c
// 版本1：递归
int fib(int n)
{
    if(n==1||n==2)
    return 1;
    else 
    return fib(n-1)+fib(n-2);
}
```
使用了递归但会造成算力的浪费。
```c
// 版本2：迭代
int fib(int n)
{
    int a = 1;
    int b = 1;
    int c = 1; // 当n<=2时，也会返回1
    
    while (n > 2)
    {
        c = a + b; // 用c来表示所求的数
        a = b; // 依次赋值
        b = c;
    }
    
    return c;
}
```
 使用迭代，使得计算量减少，避免了算力的浪费。

# 10.strcpy函数

**strcpy()**函数：是将一个字符串复制到另一块空间地址中的函数，

`\0'`是停止拷贝的终止条件，同时也会将 `'\0'` 也复制到目标空间。

下面是库中的strcpy()函数声明：

```c
char* strcpy(char* destination,const char* source);
```

> 1. 函数的参数：
>
>    - char* destination---------目标字符串的首地址
>
>    - const char* source------源地址：被复制的字符串的首地址，用const修饰，避免修改掉被拷贝的字符串
>
> 2. 函数的返回值类型：
>
>    - char*：返回的是目标字符串的首地址 

举例：

```c
#include <stdio.h>
#include <string.h>
 
int main(void)
{
	char arr[10] = "########";
	
	printf("%s\n", strcpy(arr,"hello"));
 
	return 0;
}
```

注意：

```c
#include <stdio.h>
#include <string.h>
 
int main(void)
{
	char* str1 = "hello world";
	char str2[10] = "*********";
  
	printf("%s\n", strcpy(str1,str2));
 
	return 0;
}
```

str1指向的是常量字符串，是不可以被修改掉的，目标空间必须是可以被修改的，因为要将拷贝的字符串放在目标空间中。
