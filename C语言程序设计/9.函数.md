<a name="giyo9"></a>
# 1.Sleep函数
头文件为**<windows.h>**。<br />Windows系统中的函数。可以减缓程序运行的速度，当运行该语句时，如`Sleep(2000)`时，里面的数字代表停止2000毫秒。在Windows系统中要带有**<window.h>**的头文件，而在其他系统中要其他的头文件。S为大写。
<a name="QYYjI"></a>
# 2.system函数
头文件是**<stdlib.h>。**<br />**system**函数是Windows特有的库函数，执行系统命令。如在系统命令中，`system("cls")`代表清空命令控制台,其中**cls**为系统命令。执行一次会将整个终端原有输出内容清空。<br />还有系统命令如`shutdown = -s`代表关机，`shutdown = -s -t 60`代表60秒后关机，而`shutdown = -a`代表取消关机。
<a name="nv2u6"></a>
# 3.strcmp函数
头文件为**<string.h>**。<br />**strcmp**函数是用来判断字符是否相同的函数。如果相等，它就会返回0；不相等，反之。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1695904641177-d1e766c3-7eb6-4636-b403-1be94ad41687.png#averageHue=%23f6f0eb&clientId=u97d45ed4-2a7d-4&from=paste&height=18&id=ud80f0a42&originHeight=27&originWidth=302&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=5098&status=done&style=none&taskId=u9f7aef85-8b61-4ea7-b0d0-785b5fa65fa&title=&width=201.33333333333334)
<a name="feTZr"></a>
# 4.rand函数、srand函数以及time函数
<a name="Sm2KM"></a>
## （1）rand函数
头文件为**<stdlib.h>**。<br />用法示例：

| **v1 = rand() % 100** | **v1 取值范围 0~99** |
| --- | --- |
| **v2 = rand() % 100 + 1** | **v2 取值范围 1~100** |
| **v3 = rand() % 30 + 1985** | **v3 取值范围 1985~2014** |

**rand**函数是返回一个介于0和RAND_MAX（32767）之间的伪随机整数。这个数字是由一个算法生成的，该算法每调用一次它就会产生一个毫不相关的数字序列。该算法是通过一个固定的种子来生成随机数的，因此每次运行时，产生的随机数也是相同的。<br />而**rand**函数返回值取模100，而任何一个整数除以100的余数范围在0~99之间，而加1就能表示1~100的数。<br />代码示例：
```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    int i = 0;
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", rand() % 10);
    }
    system("pause");
    return 0;
}

```
运行上述代码时，它会将每一次循环所生成的随机数打印出来。而每一次运行程序的结果均为下图所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1695966632688-992da6db-cb96-4e7d-9286-a235075dbf46.png#averageHue=%23edebe9&clientId=ucd189e01-a949-4&from=paste&height=19&id=u00c324b3&originHeight=28&originWidth=579&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=4088&status=done&style=none&taskId=u2b3b9f42-37ac-41a1-8b32-2176a5f3333&title=&width=386)
<a name="vEeIU"></a>
## （2）srand函数
头文件为**<stdlib.h>**。<br />**srand**函数是定义种子的函数，如果没有调用**srand**函数来初始化，系统会自动调用一次**srand**函数来初始化种子。每次循环初始化的种子不同，但每次运行程序时每个种子的顺序和数值都相同，导致上述结果相同。因此要通过向**srand**函数输入一个随机值，使它随机返回一个种子，从而使**rand**函数产生一个随机值。而输入的随机值是时间戳。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1695967783174-156555ad-a502-4f1c-8dbd-dfc0d19540b2.png#averageHue=%23e6e2df&clientId=u9853408e-ce93-4&from=paste&height=25&id=MyJf9&originHeight=37&originWidth=327&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=2430&status=done&style=none&taskId=ub2ed2629-8ebe-42b0-8d0a-f971f663538&title=&width=218)<br />可知**srand**函数需要输入的是一个无符号整形。
<a name="Nhxhx"></a>
## （3）time函数
头文件为**<time.h>**。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1695967862864-87ca6592-81f4-4ca9-9c9b-9cf35d723812.png#averageHue=%23eae6e4&clientId=u9853408e-ce93-4&from=paste&height=23&id=u2b8bd7ac&originHeight=34&originWidth=332&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1886&status=done&style=none&taskId=uf3f6b918-10b2-460d-af55-373adb79d81&title=&width=221.33333333333334)<br />简要介绍：<br />时间戳是指自协调世界时（UTC）1970年1月1日00:00:00开始经过的秒数，不考虑闰秒。Unix时间戳可以是正数或负数，其中正数表示1970年之后的时间，负数表示1970年之前的时间。<br />简而言之，时间戳就是一串可以代表时间的数字序列。而**time**函数的返回值类型为time_t，本质上是一个整形。而**srand**函数所需要的输入值是一个无符号整形，所以需要进行强制类型转换。而在强制类型转换中可能会有数据的丢失，但我们不要求精准的数字，只要求一个随机值，所以可以不用考虑。<br />而其输入值为一个指针变量，因此我们可以输入**NULL**（空指针）或者0。<br />代码示例：
```c
int main() 
{
	int i = 0;
	srand((unsigned int) time(0));
	for (int i = 0; i < 10; i++) 
	{
		printf("%d ", rand() % 10);
	}
	system("pause");
	return;
}
```
注意事项：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1695968630816-5b555b63-e3ec-4ff2-ab36-4b510ee92b09.png#averageHue=%232e2b21&clientId=u9853408e-ce93-4&from=paste&height=196&id=uf4311a87&originHeight=294&originWidth=932&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=88034&status=done&style=none&taskId=u5dd14659-afeb-4414-843e-22d4504ca8b&title=&width=621.3333333333334)<br />因为如果每次返回的时间间隔不超过一秒，就会返回一个相同的时间戳，从而返回一个相同的种子，从而导致每次生成的数都相同。<br />因此每次调用**time**函数（或者**srand**函数）之间放在整个工程就行了。
<a name="eIysk"></a>
# 5.sqrt函数
头文件为**<math.h>**。<br />可以求一个**double**类型的数的平方根。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1696341025982-502db7f7-af65-4dec-9da7-42ac0c45942e.png#averageHue=%23ece9e7&clientId=ub68a9bbc-20b4-4&from=paste&height=33&id=uabc20e37&originHeight=50&originWidth=247&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1719&status=done&style=none&taskId=u6d30e8e4-5160-45c3-bbe1-94dbe934272&title=&width=164.66666666666666)
<a name="JeyuM"></a>
# 6.实参和形参与传值调用和传址调用
函数传递参数可以传参数、函数和表达式(表达式可以是逗号表达式)。
<a name="wdJFQ"></a>
## （1）实参和形参
案例：交换数字。<br />错误代码示例：
```c
#include <stdio.h>

void swap(int x, int y)
{
    int temp = x;
    x = y;
    y = temp;
}

int main(void)
{
    int a = 0, b = 0;

    scanf("%d %d", &a, &b);
    swap(a, b);
    printf("%d %d\n", a, b);

    return 0;
}
```
输入和输出结果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1696138718399-a8a300d7-cee5-4aa7-9a8f-68d1c71b7743.png#averageHue=%232d2d2d&clientId=uf9028cec-7e94-4&from=paste&height=36&id=u66c9fdb0&originHeight=54&originWidth=81&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1032&status=done&style=none&taskId=uccd45659-d04d-4fcc-94f8-a207903899c&title=&width=54)<br />因为再运行swap函数的时候，仅仅是把a和b的值传给了x和y，x和y新创建了两个与a和b不同的内存空间，x与y的值确实进行了交换，但不会影响a和b的值。<br />a和b是实际参数，x和y是形式参数。两者有不同的内存空间，修改形式参数不会影响实际参数。<br />（形参是实参的临时拷贝。）<br />正确代码示范：
```c
#include <stdio.h>

void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main(void)
{
    int a = 0, b = 0;

    scanf("%d %d", &a, &b);
    swap(&a, &b);
    printf("%d %d\n", a, b);

    return 0;
}
```
在上述代码中，传给swap函数的是两个指针变量，因此指针变量的形参的地址、与实参是否相同就不重要。再通过形参的地址与外部变量建立联系，用解引用来改变外部两个变量的值，从而实现交换的效果。<br />（因此，如果想对实参进行操作，就要取地址来进行操作。）
<a name="O0YKh"></a>
## （2）传值调用和传址调用
根据错误示范，传值调用让函数对形参进行修改，因为实参与形参有不同的内存块，所以对其的修改不会影响到实参。<br />而传址调用通过传递地址从而建立起内部与外部真正的联系。<br />而全局变量不用传参。
<a name="cajTb"></a>
# 7.getchar()函数、putchar()函数
```c
#include <stdio.h>
int main()
{
 int ch = 0;
 while ((ch = getchar()) != EOF)
       putchar(ch);
    return 0;
}
```
**getchar()**便是读取键盘上输入的字符，而**putchar()**则是输出单个字符的工具。<br />上述代码实现了在键盘输入什么单个字符，就输出什么单个字符。<br />而**EOF**在键盘上表示为**ctrl+z**,当输入**EOF**时就会推出循环。（**EOF**本质是-1)<br />至于定义**ch**用整形是因为该函数的返回值是整形。用**int**既可以读取ASCII码值，也可以读取**EOF**。如果是用**char**类型就不能接收**EOF。**（**EOF**本质是-1）<br />在输出时会自动切换下一行，原因是比如输入字符**a**，需要按下回车（\n)来使其触发。此时缓冲区中有字符**a**、**\n**。此时**getchar()**去读，就会读到两者（第一次循环是**a**，第二次循环是**\n**），之后分别两次由**putchar()**来输出**getchar()**读取的字符。
<a name="CL1Zk"></a>
## （1）清理缓存区
经过简单的修改后，可以成为清理缓存区的工具。
```c
while ((ch = getchar()) != '\n')
{
	;
}/*在循环中不断地用getchar()来读取字符，
 直到读取完"\n", 也就是缓存区的所有字符，
 才跳出循环*/
```
（额外知识：**scanf**不会读取空格、\n和制表符，当读到这些时，它会停止读取，因为它把它们当成了分隔符。）
<a name="DsBW8"></a>
## （2）打印数字字符
```c
#include <stdio.h>
int main(void)
{
	char ch = '0';
	while ((ch = getchar()) != EOF)
	{
		if (ch < '0' || ch>'9')
			continue;
		putchar(ch);
	}
	return 0;
}
```
 这个代码的作用是：只打印数字字符，跳过其他字符。（也可以类比到其他的字符。）
<a name="Dngem"></a>
# 8.函数的声明与定义
如果要在后面定义函数，要满足先声明后使用，则要如下述代码：
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int Add(int, int);//函数的声明

int main(void)
{
	int a = 0;
	int b = 0;
	int sum = Add(a, b);
	printf("%d\n", sum);
	return 0;
}

int Add(int x, int y)//函数的定义
{
	return x + y;
}
```
（或者在声明处加上x和y与定义一致。）<br />函数的声明一般放在头文件中；<br />函数的定义一般放在源文件中。<br />两者形成一个模块。<br />因此，如上，创建一个add.h和add.c；<br />在原代码中，这样用：
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include "add.h"

int main(void)
{
	int a = 0;
	int b = 0;
	int sum = add(a, b);
	printf("%d\n", sum);
	return 0;
}

```
（额外：可以让代码编译成静态库，便于商业使用，而后将代码放入目录中，使用静态库时，使用下列的代码:<br />`#pragma comment(lib, "add.lib")`，这是导入静态库的方法。）
<a name="TSbJ4"></a>
# 9.函数递归
<a name="IAVMU"></a>
## 递归两个必要条件
<a name="ATuxf"></a>
### a.存在限制条件，当满足这个限制条件的时候，递归便不再继续。
<a name="FutwV"></a>
### b.每次函数调用之后越来越接近这个限制条件。
<a name="twyV6"></a>
## 例题
<a name="pE7zj"></a>
### a.
![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1696828346632-525f5f5d-be73-4273-8c36-83c9d2bcdcba.png#averageHue=%23badbbf&clientId=u11de5420-8299-4&from=paste&height=78&id=iP0vX&originHeight=97&originWidth=486&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46895&status=done&style=none&taskId=u8e2bd3b3-a89d-4666-af87-6f1e64164cd&title=&width=388.8)
```c
#include <stdio.h>
void print(unsigned int n)
{
    if (n > 9)
    {
        print(n / 10);//通过递归，在满足n为个数的情况下，跳过if语句进行打印
    }                 //而后，完成了if语句，再打印十位，完成一次print函数，以此类推
    printf("%d ", n % 10);//自己调用自己，完成递归
}
int main(void)
{
    unsigned int num = 0;
    scanf("%d", &num);
    print(num);
    return 0;
}
```
<a name="NAPj7"></a>
### b.
![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1696909735949-0221dccc-7ffb-4295-940d-f5cc37506c98.png#averageHue=%23a9d0ae&clientId=u02db4f1f-9550-4&from=paste&height=28&id=u06f8e7ca&originHeight=35&originWidth=423&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=25216&status=done&style=none&taskId=u2486e89e-e5b2-44cf-ae6c-f20a4350d98&title=&width=338.4)
```c
#include <stdio.h>

int my_strlen(char str[])
{
    if (*str != '\0')
        return 1 + my_strlen(str + 1);
        //在递过程的最后是'\0',它返回0
        //而后加上1个字符返回1
        //然后，再1个字符返回1
        //以此类推，每一个字符都返回1
        //最终归到最开始的那一层，返回字符的数量
	//扩展：如果是整形数组，str+1就代表移动四个字符，移动到下一个元素
    else
        return 0;
}

int main(void)
{
    char arr[] = "asda";

    printf("%d\n", my_strlen(arr));

    return 0;
}
```

<a name="qcpXN"></a>
### c.
n!的阶乘。
```c
int factorial(int n)
{
    if(n==1)
    return 1;
    else if(n!=1)
    return n*factorial(n-1);
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1696931503492-21619ab0-f9c7-4943-9631-f911c8438a91.png#averageHue=%23fcfcfc&clientId=u810ba97f-6fef-4&from=paste&height=376&id=u1e2d7da3&originHeight=470&originWidth=697&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=14086&status=done&style=none&taskId=uf2bf7add-7ba2-4f60-a20b-9bc28cbb23e&title=&width=557.6)
<a name="UBCQ7"></a>
### d.
斐波那契数列。
<a name="qbu2b"></a>
#### 版本1:递归
```c
int fib(int n)
{
    if(n==1||n==2)
    return 1;
    else 
    return fib(n-1)+fib(n-2);
}
```
使用了递归但会造成算力的浪费。
<a name="mvPxm"></a>
#### 版本2:迭代
```c
int fib(int n)
{
    int a = 1;
    int b = 1;
    int c = 1;//当n<=2时，也会返回1
    while (n > 2)
    {
        c = a + b;//用c来表示所求的数
        a = b;//依次赋值
        b = c;
    }
    return c;
}
```
 使用迭代，使得计算量减少，避免了算力的浪费。


