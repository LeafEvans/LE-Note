# 1.Sleep函数
头文件为**<windows.h>**。

Windows系统中的函数。可以减缓程序运行的速度，当运行该语句时，如`Sleep(2000)`时，里面的数字代表停止2000毫秒。在Windows系统中要带有**<window.h>**的头文件，而在其他系统中要其他的头文件。S为大写。

# 2.system函数
头文件是**<stdlib.h>**。

**system**函数是Windows特有的库函数，执行系统命令。如在系统命令中，`system("cls")`代表清空命令控制台，其中`cls`为系统命令。执行一次会将整个终端原有输出内容清空。

还有系统命令如`shutdown = -s`代表关机，`shutdown = -s -t 60`代表60秒后关机，而`shutdown = -a`代表取消关机。

# 3.strcmp函数
头文件为**<string.h>**。

函数原型如下：

```c
int strcmp( const char *string1, const char *string2 );
```

**strcmp**函数是用来判断字符是否相同的函数。如果相等，它就会返回0；不相等，若$str1>str2$，返回值大于0；若$str1<str2$，返回值大于0。

如下列代码：

```C
if (strcmp(str, "abc"))
{

}
```

# 4.rand函数、srand函数、time函数
## （1）rand函数
头文件为**<stdlib.h>**。

用法示例：

| **v1 = rand() % 100** | **v1 取值范围 0~99** |
| --- | --- |
| **v2 = rand() % 100 + 1** | **v2 取值范围 1~100** |
| **v3 = rand() % 30 + 1985** | **v3 取值范围 1985~2014** |

**rand**函数是返回一个介于0和RAND_MAX(32767)之间的伪随机整数。

这个数字是由一个算法生成的，该算法每调用一次它就会产生一个毫不相关的数字序列。该算法是通过一个固定的种子来生成随机数的，因此每次运行时，产生的随机数也是相同的。

而**rand**函数返回值取模100，而任何一个整数除以100的余数范围在0\~99之间，而加1就能表示1~100的数。

代码示例：

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int i = 0;
    
    for (int i = 0; i < 10; i++)
    {
        printf("%d ", rand() % 10);
    }
    system("pause");
    
    return 0;
}

```
运行上述代码时，它会将每一次循环所生成的随机数打印出来。而每一次运行程序的结果均为下图所示：

![image.png](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Ff3c26eb583da299dc224d4c9f2cfee60--3930--1695966632688-992da6db-cb96-4e7d-9286-a235075dbf46.png)

## （2）srand函数
头文件为**<stdlib.h>**。

**srand**函数是定义种子的函数，如果没有调用**srand**函数来初始化，系统会自动调用一次**srand**函数来初始化种子。每次循环初始化的种子不同，但每次运行程序时每个种子的顺序和数值都相同，导致上述结果相同。

因此要通过向**srand**函数输入一个随机值，使它随机返回一个种子，从而使**rand**函数产生一个随机值。而输入的随机值是时间戳。

```C
void srand(unsigned int seed);
```

可知**srand**函数需要输入的是一个无符号整形。

## （3）time函数
头文件为**<time.h>**。

```C
time_t time(time_t *timer);
```

简要介绍：

时间戳是指自协调世界时（UTC）1970年1月1日00:00:00开始经过的秒数，不考虑闰秒。Unix时间戳可以是正数或负数，其中正数表示1970年之后的时间，负数表示1970年之前的时间。

简而言之，时间戳就是一串可以代表时间的数字序列。而**time**函数的返回值类型为time_t，本质上是一个整形。而**srand**函数所需要的输入值是一个无符号整形，所以需要进行强制类型转换。而在强制类型转换中可能会有数据的丢失，但我们不要求精准的数字，只要求一个随机值，所以可以不用考虑。

而其输入值为一个指针变量，因此我们可以输入**NULL**（空指针）或者0。

代码示例：

```c
int main() 
{
	int i = 0;
    
	srand((unsigned int) time(0)); // 此处一定要注意，srand()一定不要写在生成随机数的函数中！
	for (int i = 0; i < 10; i++) 
	{
		printf("%d ", rand() % 10);
	}
	system("pause");
    
	return;
}
```
因为如果每次返回的时间间隔不超过一秒，就会返回一个相同的时间戳，从而返回一个相同的种子，从而导致每次生成的数都相同。

# 5.sqrt函数
头文件为**<math.h>**。

可以求一个**double**类型的数的平方根。

```C
double sqrt(double x);
```

# 6.实参和形参与传值调用和传址调用
函数传递参数可以传参数、函数和表达式（表达式可以是逗号表达式）。
## （1）实参和形参
案例：交换数字。

错误代码示例：

```c
#include <stdio.h>

void swap(int x, int y)
{
    int temp = x;
    x = y;
    y = temp;
}

int main(void)
{
    int a = 0, b = 0;

    scanf("%d %d", &a, &b);
    swap(a, b);
    printf("%d %d\n", a, b);

    return 0;
}
```
输入和输出结果：

```
10 40
10 40
```

因为再运行swap函数的时候，仅仅是把a和b的值传给了x和y，x和y新创建了两个与a和b不同的内存空间，x与y的值确实进行了交换，但不会影响a和b的值。

a和b是实际参数，x和y是形式参数。两者有不同的内存空间，修改形式参数不会影响实际参数。

（形参是实参的临时拷贝。）

正确代码示范：

```c
#include <stdio.h>

void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main(void)
{
    int a = 0, b = 0;

    scanf("%d %d", &a, &b);
    swap(&a, &b);
    printf("%d %d\n", a, b);

    return 0;
}
```
在上述代码中，传给swap函数的是两个指针变量，因此指针变量的形参的地址、与实参是否相同就不重要。再通过形参的地址与外部变量建立联系，用解引用来改变外部两个变量的值，从而实现交换的效果。

（因此，如果想对实参进行操作，就要取地址来进行操作。）

## （2）传值调用和传址调用
根据错误示范，传值调用让函数对形参进行修改，因为实参与形参有不同的内存块，所以对其的修改不会影响到实参。

而传址调用通过传递地址从而建立起内部与外部真正的联系。

而全局变量不用传参。

# 7.getchar函数、putchar函数
```c
#include <stdio.h>

int main()
{
 int ch = 0;
    
 while ((ch = getchar()) != EOF)
       putchar(ch);
    
    return 0;
}
```
**getchar()**便是读取键盘上输入的字符，而**putchar()**则是输出单个字符的工具。

上述代码实现了在键盘输入什么单个字符，就输出什么单个字符。

而**EOF**在键盘上表示为[Ctrl]+[z],当输入**EOF**时就会推出循环。（**EOF**本质是-1)

至于定义**ch**用整形是因为该函数的返回值是整形。用**int**既可以读取ASCII码值，也可以读取**EOF**。如果是用**char**类型就不能接收**EOF。**（**EOF**本质是-1）

在输出时会自动切换下一行，原因是比如输入字符**a**，需要按下回车[Enter]来使其触发。此时缓冲区中有字符**a**、**\n**。此时**getchar()**去读，就会读到两者（第一次循环是**a**，第二次循环是**\n**），之后分别两次由**putchar()**来输出**getchar()**读取的字符。

单独用**getchar()**的时候，用循环的时候，可以用`scanf(" %d")`代替。注意，在`%d`的前面有个空格，代表每次读取一个分隔符。

## （1）清理缓存区
经过简单的修改后，可以成为清理缓存区的工具。
```c
while ((ch = getchar()) != '\n')
{
	;
}
/*在循环中不断地用getchar()来读取字符，
 直到读取完"\n", 也就是缓存区的所有字符，
 才跳出循环*/
```
（额外知识：**scanf**不会读取空格、\n和制表符，当读到这些时，它会停止读取，因为它把它们当成了分隔符。）

在读取浮点数时，不需要使用`getchar`函数清除输入缓冲区。`scanf("%f", &c)`也可以正确处理换行符，因为`%f`转换说明符将自动跳过之前的任何空格字符和换行符。

## （2）打印数字字符
```c
#include <stdio.h>

int main(void)
{
	char ch = '0';
    
	while ((ch = getchar()) != EOF)
	{
		if (ch < '0' || ch>'9')
			continue;
		putchar(ch);
	}
    
	return 0;
}
```
 这个代码的作用是：只打印数字字符，跳过其他字符。（也可以类比到其他的字符。）
# 8.函数的声明与定义
如果要在后面定义函数，要满足先声明后使用，则要如下述代码：
```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int Add(int, int); // 函数的声明

int main(void)
{
	int a = 0;
	int b = 0;
	int sum = Add(a, b);
    
	printf("%d\n", sum);
    
	return 0;
}

int Add(int x, int y) // 函数的定义
{
	return x + y;
}
```
（或者在声明处加上x和y与定义一致。）

函数的声明一般放在头文件中；

函数的定义一般放在源文件中。

两者形成一个模块。

因此，如上，创建一个`add.h`和`add.c`；

在原代码中，这样用：

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include "add.h"

int main(void)
{
	int a = 0;
	int b = 0;
	int sum = add(a, b);
    
	printf("%d\n", sum);
    
	return 0;
}

```
（额外：可以让代码编译成静态库，便于商业使用，而后将代码放入目录中，使用静态库时，使用下列的代码:

`#pragma comment(lib, "add.lib")`，

这是导入静态库的方法。）

# 9.函数递归
## 递归两个必要条件

- 存在限制条件，当满足这个限制条件的时候，递归便不再继续。
- 每次函数调用之后越来越接近这个限制条件。

## 例题
- 接受一个无符号整形（无符号），按照顺序打印它的每一位

```c
#include <stdio.h>

void print(unsigned int n)
{
    if (n > 9)
    {
        print(n / 10); // 通过递归，在满足n为个数的情况下，跳过if语句进行打印
    }                 // 而后，完成了if语句，再打印十位，完成一次print函数，以此类推
    printf("%d ", n % 10); // 自己调用自己，完成递归
}

int main(void)
{
    unsigned int num = 0;
    
    scanf("%d", &num);
    print(num);
    
    return 0;
}
```
- 编写函数不允许创建临时变量，求字符串的长度

```c
// 版本1，递归函数版
#include <stdio.h>

int my_strlen(char str[])
{
    if (*str != '\0')
        return 1 + my_strlen(str + 1);
        // 在递过程的最后是'\0',它返回0
        // 而后加上1个字符返回1
        // 然后，再1个字符返回1
        // 以此类推，每一个字符都返回1
        // 最终归到最开始的那一层，返回字符的数量
	// 扩展：如果是整形数组，str+1就代表移动四个字符，移动到下一个元素
    else
        return 0;
}

int main(void)
{
    char arr[] = "asda";

    printf("%d\n", my_strlen(arr));

    return 0;
}
```

```c
// 版本2，指针变量版
int my_strlen(char *str)
{
    char *start = str; // 将字符串的第一个字符的地址放在start里面

    while (*str != '\0')
    {
        str++; // 由指针运算，每次+1都是跳过一个字节的变量长度
    }

    return (str - start); // 将最后的地址减去最开始的地址，得到的就是字符串长度，因为指针减指针代表其中元素的个数，就是字符的个数
}
```

- n!的阶乘

```c
int factorial(int n)
{
    if (n == 1)
        return 1;
    else if (n != 1)
        return n * factorial(n - 1);
}
```

$$
f(n) = 
	\begin{cases}
		1, & \text {n=1}\\
		nf(n-1), & \text {n>1}
	\end{cases}
$$

- 斐波那契数列

```c
// 版本1：递归
int fib(int n)
{
    if(n==1||n==2)
    return 1;
    else 
    return fib(n-1)+fib(n-2);
}
```
使用了递归但会造成算力的浪费。
```c
// 版本2：迭代
int fib(int n)
{
    int a = 1;
    int b = 1;
    int c = 1; // 当n<=2时，也会返回1
  
    while (n > 2)
    {
        c = a + b; // 用c来表示所求的数
        a = b; // 依次赋值
        b = c;
        n--;
    }
    
    return c;
}
```
 使用迭代，使得计算量减少，避免了算力的浪费。

# 10.strcpy函数

**strcpy()**函数：是将一个字符串复制到另一块空间地址中的函数，

`\0'`是停止拷贝的终止条件，同时也会将 `'\0'` 也复制到目标空间。

下面是库中的strcpy()函数声明：

```c
char* strcpy(char* destination,const char* source);
```

> 1. 函数的参数：
>
>    - char* destination---------目标字符串的首地址
>
>    - const char* source------源地址：被复制的字符串的首地址，用const修饰，避免修改掉被拷贝的字符串
>
> 2. 函数的返回值类型：
>
>    - char*：返回的是目标字符串的首地址 

举例：

```c
#include <stdio.h>
#include <string.h>
 
int main(void)
{
	char arr[10] = "########";
	
	printf("%s\n", strcpy(arr,"hello"));
 
	return 0;
}
```

注意：

```c
#include <stdio.h>
#include <string.h>
 
int main(void)
{
	char* str1 = "hello world";
	char str2[10] = "*********";
  
	printf("%s\n", strcpy(str1,str2));
 
	return 0;
}
```

str1指向的是常量字符串，是不可以被修改掉的，目标空间必须是可以被修改的，因为要将拷贝的字符串放在目标空间中。

自我函数的实现：

```c
#include <stdio.h>
#include <assert.h>

char *my_strcpy(char *dest, const char *src)
{
    char *ret = dest; // 存储字符串首元素的地址

    assert(src != NULL); // 这个表达式为假时，运行
    assert(dest != NULL);
    while (*dest++ = *src++)
        ;

    return ret; // 返回首元素的地址
}

int main(void)
{
    char arr1[20] = "XXXXXXXXXXXXXXX";
    char arr2[] = "hello world";

    my_strlen(arr1, arr2);
    return 0;
}
```

# 11.islower函数、isupper函数、tolower函数、toupper函数

头文件为**<ctype.h>**。

```c
int islower( int c );
```

当**islower**返回值是1时，代表传入的值时小写字母。

类似的，**isupper**的放回值是$1$时，代表传入的值时大写字母。

```c
int tolower( int c );
```

传入相应的大写字母时，会返回相应的小写字母。

如果传入的是小写字母或者非字母字符，`tolower()`函数会原样返回这个字符。

类似的，**toupper**当传入的值是小写字母时，会返回相应的大写字母。

# 12.isalpha函数、isdigit函数、isalnum函数

头文件为**<ctype.h>**。

```c
int isalpha( int c );
```

判断是否为字母，如果是，返回$1$。

类似的，isdight函数判断数字字符，isalnum函数判断数字和字母字符。

# 13.assert函数

头文件为**<assert.h>**。

```c
void assert( int expression );
```

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Fe22d31f1c049af38fa43fb957d2cef5f--e00a--image-20231107150049529.png" alt="image-20231107150049529" style="zoom:80%;" />

```c
#include <stdio.h>
#include <assert.h>

char *my_strcpy(char *dest, const char *src)
{
    char *ret = dest;

    assert(src != NULL); // 这个表达式为假时，运行
    assert(dest != NULL);
    while (*dest++ = *src++)
        ;

    return ret;
}

int main(void)
{
    char arr1[20] = "XXXXXXXXXXXXXXX";
    char arr2[] = "hello world";

    my_strlen(arr1, arr2);
    return 0;
}
```

当表达式为假时，终止程序并报错。如上述代码中，如果传了一个空指针，就会报错。

# 14.strcat函数

头文件为**<string.h>**。

将一个字符串接到另一个字符串的末尾，后者的`\0`消失。

```c
char *strcat( char *strDestination, const char *strSource );
```

```c
// 举例示范
scanf("%s", str2);
strcat(str1, str2);
```

# 15.fgets函数

头文件为**<stdio.h>**。

```c
char *fgets( char *string, int n, FILE *stream );
```

- str：指向一个字符数组的指针，用于存储读取的字符串。
- n：要读取的最大字符数（包括空字符）。
- stream：文件流指针，指向要从中读取的文件。

**fgets**函数会从指定的文件流中读取最多n-1个字符，直到遇到换行符（**包括换行符,它也会被读取**，因此如果不需要`str1[strlen(str) - 1] = '\0'; `）或者到达文件末尾为止。它将所读取的字符串存储到str指向的字符数组中，并在最后添加一个null终止符。

**fgets**函数中的参数n表示要读取的最大字符数，但实际上fgets函数会在末尾自动添加一个null终止符’\0’，因此最终存储在目标字符数组中的字符串长度为n-1。这是为了确保字符串以null终止符结束，以便其他字符串处理函数可以正确地识别字符串的结束位置。

如果成功读取了字符串，则返回str；如果到达文件末尾或者发生错误，则返回NULL。

**stdin**是一个标准C库中预定义的文件流指针，代表标准输入流。在大多数操作系统中，它通常与用户的键盘输入相关联。当你使用C语言中的函数（比如fgets、scanf等）从标准输入中读取数据时，实际上是在使用**stdin**文件流指针。

因此，**stdin**用于从键盘或其他标准输入设备中读取输入。

下面是一个示例代码，演示了如何使用fgets函数从文件中读取一行字符串：

```c
#include <stdio.h>

int main()
{
    FILE *file = fopen("example.txt", "r");
    char buffer[100];

    if (file)
    {
        if (fgets(buffer, sizeof(buffer), file) != NULL)
        {
            printf("读取的内容: %s", buffer);
        }
        else
        {
            printf("无法读取文件");
        }
        fclose(file);
    }
    else
    {
        printf("无法打开文件");
    }

    return 0;
}
```

# 16.strstr函数

头文件为**<stdio.h>**。

```c
char *strstr( const char *string, const char *strCharSet );
```

- *string*

  Null-terminated string to search(在这个字符串里找)

- *strCharSet*

  Null-terminated string to search for(找这个字符串)

Each of these functions returns a pointer to the **first** occurrence of  *strCharSet* in *string*, or **NULL** if *strCharSet* does not  appear in *string*. If *strCharSet* points to a string of zero length,  the function returns ***string***.(没找到就返回空指针)

```c
#include <stdio.h>
#include <string.h>

int main(void) 
{
    const char *str = "Hello, world! This is a test.";
    const char *subStr = "world";

    char *result = strstr(str, subStr); // 存储着第一个字符串的地址
    if (result) 
    {
        printf("子字符串 \"%s\" 在字符串中的位置：%ld\n", subStr, result - str); // 根据指针运算，进行输出第几个
    } 
    else
    {
        printf("未找到子字符串 \"%s\"\n", subStr);
    }

    return 0;
}
```

# 17.pow函数

头文件为**<math.h>**。

```c
double pow( double x, double y );
```

**pow** returns the value of $x^y$. No error message is  printed on overflow or underflow. 

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Fbc719da0a84a306b1c3898a7199ea025--ccf3--image-20231111165202078.png" alt="image-20231111165202078" style="zoom:67%;" />

# 18.strncmp函数、strncasecmp函数

头文件为**<string.h>**。

比较C字符串str1和C字符串str2的最多num个字符。
此函数开始比较每个字符串的第一个字符。如果它们彼此相等，它将继续使用以下对，直到字符不同，直到达到终止的null字符，或者直到两个字符串中的num个字符匹配，以先发生的为准。

```c
int strncmp ( const char * str1, const char * str2, size_t num );
```

举例：

```c
if (strncmp(&str1[i], str2, len2) == 0)
{
    printf("/*%.*s*/", len2, &str1[i]);
    i += len2;
}
```

上述代码代表从`str1`的第`str1[i]`个字符开始与`str2`比较，比较的字符串长度为`len2`。

# 19.strcspn函数

头文件为**\<string.h>**。

```c
size_t strcspn(const char *str1, const char *str2);
```

其中，`str1`是要检索的字符串，而`str2`是要搜索的字符集合。

`strcspn()`函数的功能是返回字符串`str1`中从开头开始的连续字符，直到第一个出现在`str2`中的字符之前的字符数。换句话说，它返回的是`str1`中不包含`str2`中任何字符的**最长前缀长度**（这可以定位字符在字符串中的位置）。

以下是一个示例：

```c
#include <stdio.h>
#include <string.h>

int main() 
{
    char str[] = "Hello, world!";
    char charset[] = "o,";
    
    size_t len = strcspn(str, charset);
    
    printf("Length of prefix without any character from charset: %zu\n", len);

    return 0;
}
```

在上面的示例中，我们将字符串`str`作为输入，并指定了字符集合`charset`。`strcspn()`函数将返回`str`中连续不包含`charset`中的任何字符的前缀的长度，即前面的部分"Hell"的长度为4。

# 20.isspace函数

头文件为`<ctype>`。

isspace是C语言标准库中的函数，用于判断一个字符是否为空白字符，包括空格、制表符、换行符、回车符、垂直制表符和换页符。isspace函数的原型是：

```c
int isspace(int ch);
```

它接受一个字符作为参数，如果这个字符是空白字符则返回非零值，否则返回0。
