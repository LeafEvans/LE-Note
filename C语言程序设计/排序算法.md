# 1.冒泡排序

<img src="https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Fb7d216a5b292cf3a5412bbc7fbb56a9e--d3e9--bubbleSort.gif" alt="img" />

```c
void bubble_sort(int arr[], int len) // 冒泡排序（从后开始产生顺序）
{
    int i = 0, j = 0;

    for (i = 0; i < len - 1; i++)         // 对len-1个元素进行排序，则最后一个元素自动排序
        for (j = 0; j < len - 1 - i; j++) // 每排好一次，在最后排好的元素就会+1
            if (arr[j] > arr[j + 1])
                swap(&arr[j], &arr[j + 1]); // 如果更大就进行交换，让大的往后排
}
```

# 2.插入排序

![img](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2Fbe81c151f38d8923fe1ede31ac530ac4--be2d--insertionSort.gif)

```c
void insertion_sort(int arr[], int len) // 插入排序（从前开始产生顺序）
{
    int i = 0, j = 0, key = 0; // 两个用于循环的变量和插入的变量

    for (i = 1; i < len; i++) // 从arr[1]的元素开始排
    {
        key = arr[i];                                // 将要插入的变量定义为arr[i]
        for (j = i - 1; j >= 0 && arr[j] > key; j--) // 定义另一个j=i-1的，代表开始与前一个进行比较；j>=0并且key比这个数小执行循环
            arr[j + 1] = arr[j];                     // 代表把这些元素向后排
        arr[j + 1] = key; // 不满足循环代表arr[j]此时比key小或者j<0；而arr[j+2]==arr[j+1]，把arr[j+1]=key
    }
}
```

# 3.选择排序

![img](https://leafalice-image.oss-cn-hangzhou.aliyuncs.com/img/2023-11-23%2F44be35da53ae9ee564ce444542a43d10--6739--selectionSort.gif)

```c
void selection_sort(int arr[], int len) // 选择排序（从前开始产生顺序）
{
    int i = 0, j = 0, min = 0; // 两个循环变量和最小量的下标

    for (i = 0; i < len - 1; i++) // 代表排序的次数，只要由len-1个排好，剩下的就会排好
    {
        min = i; // 先定义最小量下标为i

        for (j = i + 1; j < len; j++) // 从i+1项开始进行比较
            if (arr[j] < arr[min])    // 如果更小就更新min下标
                min = j;
        swap(&arr[min], &arr[i]); // 把最小量赋值给arr[i]
    }
}
```

