<a name="CpF7J"></a>
# 1.最大公约数
**【题目内容】**<br />给定两个数，求这两个数的最大公约数<br />例如：<br />输入：20 40 <br />输出：20
```c
#include <stdio.h>
int main(void)
{
	int a, b, c;//定义了三个整形变量
	scanf("%d %d", &a, &b);//输入
	while (c = a % b)
	{
		a = b;
		b = c;
	}
	/*
	将a/b的余数赋值给c，
	并且利用C语言的真假特性（即零为假，非零为真），
	制定循环
	*/
	printf("%d", b);//输出除数b
	return 0;
}
```
**【解析】**<br />根据辗转相除法，取两个数，一个充当被除数，一个充当除数，求两者最大公约数。当被除数除以除数的余数为零时，除数即为最大公约数。当被除数除以除数的余数不为零，此时将被除数替换为原来的除数，除数替换为原来的余数；然后重复上述的步骤，当余数为零时，此时除数就为最大公约数。

<a name="mxGQY"></a>
# 2.**出生日期输入输出**
<a name="aPfzV"></a>
## 描述
输入一个人的出生日期（包括年月日），将该生日中的年、月、日分别输出。<br />数据范围：年份满足 1990≤_y_≤2015 ，<br />月份满足 1≤_m_≤12  ，<br />日满足  1≤_d_≤30  。
<a name="zBb8M"></a>
### 输入描述：
输入只有一行，出生日期，包括年月日，年月日之间的数字没有分隔符。
<a name="eupnZ"></a>
### 输出描述：
三行，第一行为出生年份，第二行为出生月份，第三行为出生日期。输出时如果月份或天数为1位数，需要在1位数前面补0。
<a name="LxHZ8"></a>
## 示例
:::info
输入：20130225 <br />输出：year=2013 <br />          month=02 <br />          date=25
:::
<a name="yYZmD"></a>
## 解析
```c
#include <stdio.h>
int main(void)
{
	int year, month, day;
	scanf("%4d%2d%2d", &year, &month, &day); 
	printf("year=%d\nmonth=%02d\nday=%02d\n",year,month,day);
	return 0;
}
```
**%4d%2d%2d**表示输入一个8位数，分成4位数、2位数、2位数放在三个不同的变量中。在**scanf**函数中，**%md**（m表示一个常数）会读取m位数。而**printf**函数也有相似的效果，即输出m位数。而前面加上**%0**则会将空缺的位（即空格）用0来填充。<br />（类似的还有**%.2f**之类的来表示小数点后两位，**%-2d**代表左对齐两格，**%2d**代表右对齐两格。还有**%*2d**代表不读取这两位数，如`scanf("%2d%*2d%2d", &a, &b);`代表输入一个6位数，前面两位赋给a，后面两位赋给b，中间两位不读取。）
<a name="MQnIn"></a>
# 3.**学生基本信息输入输出**
<a name="D4dyK"></a>
## 描述
依次输入一个学生的学号，以及3科（C语言，数学，英语）成绩，在屏幕上输出该学生的学号，3科成绩（注：输出成绩时需进行四舍五入且保留2位小数）。<br />数据范围：学号满足 1≤_n_≤20000000  ，各科成绩使用百分制，且不可能出现负数。
<a name="yd5PR"></a>
### 输入描述：
学号以及3科成绩，学号和成绩之间用英文分号隔开，成绩之间用英文逗号隔开。
<a name="MVZ7l"></a>
### 输出描述：
学号，3科成绩，输出格式详见输出样例。
<a name="nPTC7"></a>
## 示例
:::info
输入：17140216;80.845,90.55,100.00<br />输出：The each subject score of No. 17140216 is 80.85, 90.55, 100.00.
:::
<a name="NIzjR"></a>
## 解析
```c
#include <stdio.h>
int main(void)
{
	int id = 0;
	float c = 0.0f, math = 0.0f, eng = 0.0f;
	scanf("%d;%f,%f,%f",&id,&c,&math,&eng);
	printf("The each subject score of No. %d is %.2f, %.2f, %.2f", id, c, math, eng);
	return 0;
}
```
定义浮点型时在0.0后加上f是因为浮点数默认是**double**类型的，而不是**float**类型的。
<a name="tMUG3"></a>
# 4.**小乐乐找最大数**
<a name="ckTVA"></a>
## 描述
小乐乐获得4个最大数，请帮他编程找到最大的数。
<a name="J8o8m"></a>
### 输入描述：
一行，4个整数，用空格分开。
<a name="TIlB0"></a>
### 输出描述：
一行，一个整数，为输入的4个整数中最大的整数。
<a name="k7Or1"></a>
## 示例
:::info
输入：5 8 2 5<br />输出：8
:::
<a name="H4MK6"></a>
## 解析
```c
#include <stdio.h>
int main(void)
{
	int arr[4] = { 0 };		/*定义了一个大小为四的数组*/
	int i = 0;				/*定义了一个变量i*/
	while (i < 4)			/*使用循环遍历数组，对每个元素进行输入*/
	{
		scanf("%d", &arr[i]);
		i++;
	}
	i = 0;					/*重新将i定义为零*/
	int max = arr[0];		/*先假定最大数为数组第一个元素*/
	while (i < 4)			/*使用循环将max与数组内每一个元素作比较，定义新的max*/
	{
		if (arr[i] > max)
			max = arr[i];
		i++;
	}
	printf("%d", max);		//输出max
	return 0;
}
```
打擂台！
```c
#include <stdio.h>
int main(void)
{
	int max = 0;		//定义三个变量
	int i = 1;			//i = 1，使得等会还有三次输入
	int n = 0;

	scanf("%d", &max);	//假定最大值
	while (i < 4)		//利用循环，比较新输入的值与max的大小
	{
		scanf("%d", &n);
		if (n > max)
			max = n;	//若新输入的更大，则将max替换为n
		i++;
	}
	printf("%d", max);

	return 0;
}
```
<a name="dLYkk"></a>
# 5.求n的阶乘
```c
#include <stdio.h>
int main(void)
{
    int n = 0, i = 0, ret = 1;//定义三个变量
    scanf("%d", &n);          //输入n的值  
    for (i = 1; i <= n; i++)  //每次循环都会增大i的值  
    {
        ret *= i;             //ret每次乘增大的i的值，直到i等于n
    }
    printf("%d", ret);        //输出
    return 0;
}
```
（考察循环语句的知识。）
<a name="ShtB3"></a>
# 6.求1!+2!+...+10!的值
<a name="NcpOk"></a>
## （1）方法一
```c
#include <stdio.h>
int main(void)
{
    int n = 0, i = 0, ret = 1, sum = 0;  //定义了四个变量
    for (n = 1; n <= 10; n++)            //n的循环
    {
        for (i = 1, ret = 1; i <= n; i++)
        /*i的循环，并且在每次的外层循环结束后，初始化ret*/
        {                                   
            ret *= i;                     //与求n的阶乘方法类似
        }
        sum += ret;                       //求sum的值 
    }
    printf("%d", sum);                    //打印
    return 0;
}
```
<a name="sxkNk"></a>
## （2）方法二

```c
#include <stdio.h>
int main(void)
{
    int i = 0, j = 1, n = 0;    //定义三个整形
    for (i = 1; i <= 10; i++)   //for循环
    {
        j *= i;                 /*每次循环，每个阶乘都乘一个比最大数大一的数*/
        n += j;                 /*形成新的阶乘，而后求和*/
    }
    printf("%d", n);            //输出
    return 0;
}
```
<a name="mDQYO"></a>
# 7.二分法查找指定元素（有序数组）
<a name="bl9ZZ"></a>
## 普通版：
```c
#include <stdio.h>

int main(void)
{
    // 定义有序整型数组
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 从标准输入读取要查找的元素
    int n = 0;
    scanf("%d", &n);

    // 计算数组大小并初始化左右边界及中间位置
    int sz = sizeof(arr) / sizeof(arr[0]);
    int leaf = 0;
    int right = sz - 1;
    int mid = (leaf + right) / 2;

    // 循环执行二分查找
    while (leaf <= right)
    {
        mid = (leaf + right) / 2;
        if (arr[mid] < n)
        { // 如果中间元素小于指定元素，则调整左边界即找右侧
            leaf = mid + 1;
        }
        else if (arr[mid] > n)
        { // 如果中间元素大于指定元素，则调整右边界即找左侧
            right = mid - 1;
        }
        else
        { // 如果中间元素恰好等于指定元素，则退出循环
            break;
        }
    }

    // 根据查找结果输出提示信息
    if (arr[mid] == n)
    {
        printf("找到了，下标是 %d\n", mid);
    }
    else if (leaf > right)
    {
        printf("找不到\n");
    }

    return 0;
}

```
若**i**大于指定数组的大小，如**n = 17**，则**n**始终大于**right**，则会一直执行**else if**语句，最终使得左边界大于右边界，跳出循环。而后执行外部的**else if**语句。
:::info
**mid = (leaf + right) / 2**语句可用**mid = leaf + (rigth - leaf) / 2**语句来替代，防止**leaf + right**的数据超出整形所能表示的范围导致数据溢出，从而造成数据的缺失。
:::
<a name="hwKvf"></a>
## 函数版：
```c
#include <stdio.h>
int binary_search(int arr[10], int x, int y)
{
    int leaf = 0;
    int right = y - 1;
    while (leaf <= right)
    {
        int mid = leaf + (right - leaf) / 2;
        if (x < arr[mid])
        {
            right = mid - 1;
        }
        else if (x > arr[mid])
        {
            leaf = mid + 1;
        }
        else
        {
            return mid;
        }
    }
    return -1;
}
int main(void)
{
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int k = 0;
    int n = 0;
    int sz = sizeof(arr) / sizeof(arr[0]);
    scanf("%d", &k);
    if ((n = binary_search(arr, k, sz)) == -1)
    {
        printf("没找到,超出寻找范围\n");
    }
    else
    {
        printf("找到了，下标是%d\n", n);
    }
    return 0;
}
```
:::info
在 C 语言中，数组作为函数参数时会退化为指针类型，此时无法在函数内部直接求得数组的元素个数。这是因为数组传递给函数时，只传递了数组的首地址，并没有传递数组的长度信息。
:::
所以，当你在函数内部使用 **sizeof(arr) / sizeof(arr[0])** 的方式计算数组的长度时，实际上是计算了指针的大小除以数组元素的大小，结果始终为 1 或者任意固定的值，无法得到正确的数组长度。<br />为了解决这个问题，你需要通过额外的参数将数组的长度传递给函数。例如，在你修复的代码中，你添加了一个参数 y 来表示数组的长度，并将其作为二分查找的边界条件。这样，你就能在函数内部正确地使用这个长度信息。
<a name="BKe8W"></a>
# 8.字符串由两端向中间显现
```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char arr1[] = "Welcome to SCU!!!!";//定义两个字符数组
    char arr2[] = "##################";
    int i = 0, j = strlen(arr2) - 1;//定义左右边界

    while (i < j + 2)//替换完中间两个数字后，又进行了i++，j--，导致不满足循环条件，跳出循环，无打印
    {                //因此通过改变循环条件是，使i<j+2时跳出循环，就是在进行完i++，j--的计算后，i=9，j=8  
        printf("%s\n", arr2);//满足条件，继续循环
        arr2[i] = arr1[i], arr2[j] = arr1[j];
        i++, j--;
    }

    return 0;
}
```
输出效果：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1695902336949-6b667cd3-7eb8-4d9b-87d3-fbfa09bb1c70.png#averageHue=%23ebe9e7&clientId=ub3dcc61d-b295-4&from=paste&height=181&id=u604d9ee3&originHeight=271&originWidth=363&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=16512&status=done&style=none&taskId=ue1e96d13-ca6a-464b-a63b-15318af3891&title=&width=242)
<a name="NfOGe"></a>
# 9.模拟用户登录情景
```c
#include <stdio.h>
#include <string.h>
int main(void)
{
    int i = 0;
    char passwd[20];
    for (i = 1; i < 4; i++)
    {
        printf("请输入密码:>");
        scanf("%s", passwd);
        if (strcmp(passwd, "abc123") == 0)
        {
            printf("登录成功\n");
            break;
        }
        else if (i < 3)
        {
            printf("密码错误，您还有%d次机会", 3 - i);
        }
        else
        {
            printf("您的账号已锁定");
        }
    }
    return 0;
}
```
<a name="NWIX6"></a>
# 10.

<a name="W7TwO"></a>
# 11.打印100~200之间的素数
<a name="nqszH"></a>
## 版本一：
```c
#include <stdio.h>
int main(void)
{
    int i = 0;                  //定义变量
    for (i = 100; i <= 200; i++)//制定循环
    {
        int j = 0, flag = 1;    //定义两个变量
        for (j = 2; j < i; j++) //判断i是否为素数
        {
            if (i % j == 0)     //判断模是否为0
            {
                flag = 0;       //如果模为0
                break;          //改变flag的值
            }                   //跳出这层循环
        }
        if (flag == 1)          //如果flag为1
            printf("%d\n", i);  //说明在循环过程中
    }                           //flag一直没有被改变
    return 0;                   //即所有的2~i-1的数
}                               //都无法整除i，打印
```
<a name="YJ7Da"></a>
## 版本二：
```c
for (j = 2; j <= sqrt(i); j++)
```
将第二层循环条件改变。因为如果一个数不是素数，它的两个因子中的其中一个，必定小于该数的平方根，只要判断有无小于平方根而大于1的那个因子即可。如果有，就会整除；如果无，在该平方根之后也不可能找到另一个因子。
<a name="l70WL"></a>
## 版本三：
```c
for (i = 101; i <= 200; i += 2)
```
将第一层循环条件改变。因为一个数如果是素数，必定不是偶数，所以循环条件改成奇数判断。
<a name="xA0n1"></a>
## 函数版：
```c
#include <stdio.h>
#include <math.h>

int is_prime(int n)
{
    int i = 0;
	
    for (i = 2; i <= sqrt(n); i++)
    {
        if (n % i == 0)
            return 0; // 当遇到整除的时候，就会返回0
    }
	
    return 1; // 当没有整除的时候，就会返回1
}

int main(void)
{
    int i = 0;
    int count = 0;
	
    for (i = 101; i <= 200; i += 2)
    {
        if (is_prime(i))
        {
            printf("%d\n", i);
            count++;
        }
    }
    printf("\ncount = %d\n", count);
	
    return 0;
}
```
<a name="B4jSs"></a>
# 12.调用一次函数，num的值加一
错误示范：
```c
#include <stdio.h>

void Add(int *x)
{
    *x++;
}

int main(void)
{
    int num = 0;
	
    Add(&num);
    Add(&num);
    printf("%d\n", num);
	
    return 0;
}
```
***x++**这个语句因为没有括号，执行流程是这样的：<br />先对指针变量**x**进行解引用，再对指针变量**x**进行**++**操作。<br />因此：
```c
#include <stdio.h>

void Add(int *x)
{
    (*x)++;
}

int main(void)
{
    int num = 0;
	
    Add(&num);
    Add(&num);
    printf("%d\n", num);
	
    return 0;
}
```
**(*x)++**来正确的表示。<br />因此，在解引用操作中，最好把解引用的指针变量用小括号给圈起来。
<a name="awE6S"></a>
# 13.从大到小输出
```c
#include <stdio.h>
int main(void)
{
    int a = 0;
    int b = 0;
    int c = 0;
    int temp = 0;

    scanf("%d %d %d", &a, &b, &c);
    if(b>a)
    {
        temp=a;
        a=b;
        b=temp;
    }
    if(c>a)
    {
        temp=a;
        a=c;
        c=temp;
    }
    if(c>b)
    {
        temp=c;
        c=b;
        b=temp;
    }
    printf("%d %d %d\n",a,b,c);

    return 0;
}
```
<a name="K5saM"></a>
# 14.汉诺塔问题
大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。<br />![99ba549ce59a40b1a7f30570b2483a21.gif](https://cdn.nlark.com/yuque/0/2023/gif/38980263/1697073569580-9a1a83f7-b2aa-44eb-b85e-bcfb4864ae08.gif#averageHue=%23f8f4f0&clientId=u6460d443-afc6-4&from=ui&id=udf901486&originHeight=446&originWidth=726&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=980141&status=done&style=none&taskId=uf8fe6f10-6790-4ff2-a54a-ba5575ace04&title=)<br />若有n个圆盘，由参考系，将A柱最底下的圆盘当成地面，先做A->B的n-1个汉诺塔问题。然后在将A柱最底下的圆盘由A->C,而后再做B->C的n-1汉诺塔问题。<br />由此，代码如下：
```c
#include <stdio.h>

void move(char A, char B, int n)
{
    printf("把第%d个圆盘从%c->%c\n", n, A, B);
    //定义move函数，实现两柱圆盘移动
}

void HanoiTower(char A, char B, char C, int n)
{
    if (1 == n)
        move(A, C, n);
        //若n=1，直接A->C
    else
    //n>1
    {
        HanoiTower(A, C, B, n - 1);
        //先实现A->B的n-1个汉诺塔问题
        move(A, C, n);
        //移动A柱底层圆盘
        HanoiTower(B, A, C, n - 1);
        //再实现B->C的n-1个汉诺塔问题
    }
}
```
<a name="C50yx"></a>
# 15.韩信点兵
<a name="Sr3D3"></a>
## 描述
都听说过“韩信点兵，多多益善”这个成语，韩信才智过人，从不直接清点人数。只要让士兵 33 人一排，55 人一排，77 人一排的变换队形，查看队尾人数便能清点队伍总人数。
<a name="mjdx7"></a>
## 输入
第1行是一个整数 _n_，表示随后有 _n_ 组数据。每组数据占一行，包括三种队形的队尾人数_a_,_b_,_c_，用空格隔开。已知队伍总人数不小于 10，不大于100。
<a name="PjK4r"></a>
## 输出
对每组数据，输出相应的队伍总人数，并换行。不存在则输出** Impossible**，并换行。
<a name="V7Bhd"></a>
## 示例
<a name="kwtoy"></a>
### 输入
```c
3
1 1 2
2 4 6
2 3 6
```
<a name="fJHoP"></a>
### 输出
```c
16
Impossible
83
```
<a name="V7CEr"></a>
## 解析
```c
int count_soliders(int num1, int num2, int num3) // 暴力穷举
{
    int i = 10;

    while (1)
    {
        if (i > 100)
            return 0;
        if ((i % 3 == num1) && (i % 5 == num2) && (i % 7 == num3)) // 满足条件就输出
            return i;
        i++;
    }
}
```
<a name="xLdae"></a>
# 16.回文数
<a name="FKkYO"></a>
## 描述
程序中输入一个正整数，请判断他是否为回文数。<br />提示：回文数：类似1234321，123321等这样，顺序和逆序相同的整数称为回文数。
<a name="Z9jYv"></a>
## 输入
一个正整数n。
<a name="pRD0l"></a>
## 输出
若n是回文数，输出Yes，否则输出No。
<a name="N39t4"></a>
## 解析
```c
#include <stdio.h>

int is_palindrome(int num)
{
    int orignal_num = num; // 原本的数
    int reverse_num = 0;   // 倒着的数

    while (num)                                    // 限定条件，当num>0时，才会循环，因为它是整数除法，所以最后不会产生小数，而是零
    {                                              // 零为假，跳出循环
        reverse_num = reverse_num * 10 + num % 10; // 先加上取余得到个位
        num /= 10;                                 // 一次循环后，num除以10再赋给num，而反转数个位上的2乘上10，变成十位上的2
    }                                              // 之后再加上新的num取模得到的新的个位，如此循环，形成与原数顺序相反的数
    if (orignal_num == reverse_num)                // 判断顺序与倒序是否相等
        return 1;
    else
        return 0;
}
```
<a name="j8PfW"></a>
# 17.字符串逆序
<a name="pXDA3"></a>
## 方法一:
```c
#include <stdio.h>
#include <string.h>

void swap(char *a, char *b)
{
    char temp = *a;

    *a = *b;
    *b = temp;
}

void reverse_string(char *str)
{
    int leaf = 0;
    int right = strlen(str) - 1; // 注意右下标是字符串长度减一
                                 // strlen()可以在数组中使用，本质上也是将指针传给它，与运算符sizeof()不同
    while (leaf < right)
    {
        swap(&str[leaf], &str[right]);
        leaf++;
        right--;
    }
}
```
<a name="Otppt"></a>
## 方法二:
```c
void reverse_string(char *str) // 传字符串第一个字符的地址
{
    char tem = *str;       // 将第一个字符赋给临时变量tem
    int len = strlen(str); // 计算字符串的长度

    *str = *(str + len - 1);     // 将最后一个字符赋给第一个字符
    *(str + len - 1) = '\0';     // 最后一个字符赋值为'\0'，形成新的字符末尾
    if (strlen(str + 1) > 1)     // 计算下一次递归的字符串长度，当2个字符及以上后，进行递归(因为两个字符及以上才要交换)
        reverse_string(str + 1); // 进行递归，每次递归都会创建一个新的临时变量存储字符串第一个字符
    *(str + len - 1) = tem;      // 将临时变量赋给字符串最后一个字符
}
```

![image.png](https://cdn.nlark.com/yuque/0/2023/png/38980263/1697807039832-1a5994f6-2dbf-4b4b-a230-f9cc5083b3bf.png#averageHue=%23f5f5f5&clientId=u100beece-9f20-4&from=paste&height=298&id=u438a5614&originHeight=373&originWidth=397&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17061&status=done&style=none&taskId=u189fde74-b5ea-4c81-892c-0924d5bd75c&title=&width=317.6)
<a name="QcGM1"></a>
# 18.n的k阶乘
```c
double Pow(int n, int k) // 注意k的不同情况
{
    if (k > 0)
        return n * Pow(n, k - 1);
    else if (k < 0)
        return (1.0 / n) * Pow(n, k + 1);
    else
        return 1;
}
```
